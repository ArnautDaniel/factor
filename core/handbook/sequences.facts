IN: sequences
USING: arrays bit-arrays byte-arrays help kernel
kernel-internals sequences-internals strings sbufs vectors words
;

ARTICLE: "sequence-implementations" "Sequence implementations"
"General purpose, fixed-length sequences:"
{ $subsection "arrays" }
{ $subsection "strings" }
{ $subsection "byte-arrays" }
{ $subsection "bit-arrays" }
"Resizable sequences:"
{ $subsection "vectors" }
{ $subsection "sbufs" }
"Integers support the sequence protocol:"
{ $subsection "sequences-integers" }
"Virtual sequences wrap an underlying sequence, and changes to the underlying sequence are reflected in the virtual sequence. Virtual sequences implemented in the core are " { $link <reversed> } ", " { $link <slice> } " and " { $link <column> } "."
$nl
"Quotations are special sequences which hold code; see "
{ $link "quotations" } "."
$nl
"The " { $link f } " object also supports the sequence protocol. It responds with a length of zero, and instead of throwing an out of bounds error, outputs " { $link f } " when an element is accessed. This can simplify code that would like a dummy sequence behaving as if it has arbitrary length." ;

ARTICLE: "sequences-integers" "Integer sequences and counted loops"
"Integers support the sequence protocol in a trivial fashion; a non-negative integer presents its non-negative predecessors as elements. For example, the integer 3, when viewed as a sequence, contains the elements 0, 1, and 2. This is very useful for performing counted loops."
$nl
"For example, the " { $link each } " combinator, given an integer, simply calls a quotation that number of times, pushing a counter on each iteration that ranges from 0 up to that integer:"
{ $example "3 [ . ] each" "0\n1\n2" }
"A common idiom is to iterate over a sequence, while also maintaining a loop counter. This can be done using " { $link 2each } ":"
{ $example "{ \"a\" \"b\" \"c\" } dup length [\n    \"Index: \" write . \"Element: \" write .\n] 2each" "Index: 0\nElement: \"a\"\nIndex: 1\nElement: \"b\"\nIndex: 2\nElement: \"c\"" }
"Combinators that produce new sequences, such as " { $link map } ", will output an array if the input is an integer." ;

ARTICLE: "sequences-access" "Accessing sequence elements"
{ $subsection ?nth }
{ $subsection first }
{ $subsection second }
{ $subsection third }
{ $subsection fourth }
{ $subsection first2 }
{ $subsection first3 }
{ $subsection first4 }
{ $subsection last/first }
{ $see-also nth peek } ;

ARTICLE: "sequences-combinators" "Sequence combinators"
"Iteration:"
{ $subsection each }
{ $subsection each-with }
{ $subsection reduce }
{ $subsection interleave }
{ $subsection 2each }
{ $subsection 2reduce }
"Mapping:"
{ $subsection map }
{ $subsection map-with }
{ $subsection accumulate }
{ $subsection 2map }
"Filtering:"
{ $subsection subset }
{ $subsection subset-with } ;

ARTICLE: "sequences-tests" "Testing sequences"
"Testing for an empty sequence:"
{ $subsection empty? }
"Testing indices:"
{ $subsection bounds-check? }
"Testing if a sequence contains an object:"
{ $subsection member? }
{ $subsection memq? }
"Testing if a sequence contains a subsequence:"
{ $subsection head? }
{ $subsection tail? }
{ $subsection subseq? }
"Testing if a sequence contains elements satisfying a predicate:"
{ $subsection contains? }
{ $subsection contains-with? }
{ $subsection all? }
{ $subsection all-with? }
"Testing how elements are related:"
{ $subsection monotonic? }
{ $subsection all-eq? }
{ $subsection all-equal? } ;

ARTICLE: "sequences-search" "Searching sequences"
"Finding the index of an element:"
{ $subsection index }
{ $subsection index* }
{ $subsection last-index }
{ $subsection last-index* }
"Finding the start of a subsequence:"
{ $subsection start }
{ $subsection start* }
"Finding the index of an element satisfying a predicate:"
{ $subsection find }
{ $subsection find* }
{ $subsection find-with }
{ $subsection find-with* }
{ $subsection find-last }
{ $subsection find-last-with }
{ $subsection find-last* }
{ $subsection find-last-with* } ;

ARTICLE: "sequences-join-split" "Joining and splitting sequences"
"Forming new sequences from existing sequences:"
{ $subsection append }
{ $subsection 3append }
{ $subsection concat }
{ $subsection join }
"Slicing sequences:"
{ $subsection subseq }
{ $subsection head }
{ $subsection tail }
{ $subsection head* }
{ $subsection tail* }
"Variants of the above which output a virtual sequence sharing storage with the input sequence:"
{ $subsection <slice> }
{ $subsection head-slice }
{ $subsection tail-slice }
{ $subsection head-slice* }
{ $subsection tail-slice* }
"Splitting sequences at specific indices:"
{ $subsection cut }
{ $subsection cut* }
{ $subsection unclip }
"Splitting sequences at occurrences of subsequences:"
{ $subsection ?head }
{ $subsection ?tail }
{ $subsection split1 }
{ $subsection split }
{ $subsection drop-prefix } ;

ARTICLE: "sequences-add-remove" "Adding and removing sequence elements"
"Adding elements:"
{ $subsection add }
{ $subsection add* }
"Removing elements:"
{ $subsection remove }
{ $subsection diff }
{ $subsection prune } ;

ARTICLE: "sequences-reshape" "Reshaping sequences"
{ $subsection reverse }
{ $subsection <reversed> }
{ $subsection group }
{ $subsection flip }
{ $subsection <column> }
{ $subsection unpair }
{ $subsection subst } ;

ARTICLE: "sequences-destructive" "Destructive operations"
"These words modify their input, instead of creating a new sequence."
$nl
"In-place variant of " { $link reverse } ":"
{ $subsection reverse-here }
"In-place variant of " { $link append } ":"
{ $subsection push-all }
"In-place variant of " { $link remove } ":"
{ $subsection delete }
"In-place variant of " { $link map } ":"
{ $subsection change-each }
"Changing elements:"
{ $subsection change-nth }
{ $subsection cache-nth }
"Deleting elements:"
{ $subsection delete-nth }
{ $subsection delete-slice }
{ $subsection delete-all }
"Other destructive words:"
{ $subsection move }
{ $subsection exchange }
{ $subsection push-new }
{ $subsection copy }
{ $subsection replace-slice }
{ $see-also set-nth push pop "sequences-stacks" } ;

ARTICLE: "sequences-stacks" "Treating sequences as stacks"
"The classical stack operations, modifying a sequence in place:"
{ $subsection peek }
{ $subsection push }
{ $subsection pop }
{ $subsection pop* }
"Lazy instantiation of stacks:"
{ $subsection ?push }
{ $see-also empty? } ;

ARTICLE: "sequences-comparing" "Comparing sequences"
"Element equality testing:"
{ $subsection sequence= }
{ $subsection mismatch }
"The " { $link <=> } " generic word performs lexicographic comparison when applied to sequences." ;

ARTICLE: "sequence-protocol" "Sequence protocol"
"All sequences must know their length, and provide a way to access elements:"
{ $subsection length }
{ $subsection nth }
"Mutable sequences:"
{ $subsection set-nth }
"Resizable sequences:"
{ $subsection set-length }
"An optional generic word for creating sequences of the same class as a given sequence:"
{ $subsection like }
"Another optional generic word for optimization purposes:"
{ $subsection new } ;

ARTICLE: "arrays" "Arrays"
"An array is a fixed-size mutable sequence whose elements are stored in a contiguous range of memory. The literal syntax is covered in " { $link "syntax-arrays" } ". Sometimes you need a resizable array -- this is called a vector, and vectors are documented in " { $link "vectors" } "."
$nl
"Array words are in the " { $vocab-link "arrays" } " vocabulary. Unsafe implementation words are in the " { $vocab-link "kernel-internals" } " vocabulary."
$nl
"Arrays form a class of objects."
{ $subsection array }
{ $subsection array? }
"There are several ways to construct arrays."
{ $subsection >array }
{ $subsection <array> }
{ $subsection 1array }
{ $subsection 2array }
{ $subsection 3array }
{ $subsection 4array }
"Arrays can be accessed without bounds checks in a pointer unsafe way."
{ $subsection array-nth }
{ $subsection set-array-nth } ;

ARTICLE: "strings" "Strings"
"A string is a fixed-size mutable sequence of characters. The literal syntax is covered in " { $link "syntax-strings" } "."
$nl
"String words are found in the " { $vocab-link "strings" } " vocabulary."
{ $subsection string? }
{ $subsection >string }
{ $subsection <string> }
"A pair of words are used to nicely format columns of text."
{ $subsection pad-left }
{ $subsection pad-right }
"Characters are not a first-class type; they are simply represented as integers between 0 and 65535. A few words operate on characters:"
{ $subsection blank? }
{ $subsection letter? }
{ $subsection LETTER? }
{ $subsection digit? }
{ $subsection printable? }
{ $subsection control? }
{ $subsection quotable? }
{ $subsection ch>lower }
{ $subsection ch>upper } ;

ARTICLE: "byte-arrays" "Byte arrays"
"A byte array is a fixed-size mutable sequence whose elements are integers in the range 0-255, inclusive. Each element only uses one byte of storage, hence the name. The literal syntax is covered in " { $link "syntax-byte-arrays" } "."
$nl
"Byte array words are in the " { $vocab-link "byte-arrays" } " vocabulary."
$nl
"Byte arrays play a special role in the C library interface; they can be used to pass binary data back and forth between Factor and C. See " { $link "c-byte-arrays" } "."
$nl
"Byte arrays form a class of objects."
{ $subsection byte-array }
{ $subsection byte-array? }
"There are several ways to construct byte arrays."
{ $subsection >byte-array }
{ $subsection <byte-array> } ;

ARTICLE: "bit-arrays" "Bit arrays"
"A bit array is a fixed-size mutable sequence whose elements are either " { $link t } " or " { $link f } ". Each element only uses one bit of storage, hence the name. The literal syntax is covered in " { $link "syntax-bit-arrays" } "."
$nl
"Bit array words are in the " { $vocab-link "bit-arrays" } " vocabulary."
$nl
"Bit arrays form a class of objects."
{ $subsection bit-array }
{ $subsection bit-array? }
"There are several ways to construct bit arrays."
{ $subsection >bit-array }
{ $subsection <bit-array> } ;

ARTICLE: "sbufs" "String buffers"
"A string buffer is a resizable mutable sequence of characters. The literal syntax is covered in " { $link "syntax-sbufs" } "."
$nl
"String buffers can be used to construct new strings by accumilating substrings and characters, however usually they are only used indirectly, since the sequence construction words are more convenient to use in most cases (see " { $link "namespaces-make" } ")."
$nl
"String buffer words are found in the " { $vocab-link "sbufs" } " vocabulary."
{ $subsection sbuf? }
"Words for creating string buffers:"
{ $subsection >sbuf }
{ $subsection <sbuf> }
"If you don't care about initial capacity, a more elegant way to create a new string buffer is to write:"
{ $code "SBUF\" \" clone" } ;

ARTICLE: "vectors" "Vectors"
"A vector is a resizable mutable sequence of objects. The literal syntax is covered in " { $link "syntax-vectors" } ". Vector words are found in the " { $vocab-link "vectors" } " vocabulary."
{ $subsection vector? }
"Words for creating vectors:"
{ $subsection >vector }
{ $subsection <vector> }
"If you don't care about initial capacity, a more elegant way to create a new vector is to write:"
{ $code "V{ } clone" } ;

ARTICLE: "sequences-sorting" "Sorting and binary search"
"Sorting and binary search combinators all take comparator quotations with stack effect " { $snippet "( elt1 elt2 -- n )" } " that order the two given elements and output a value whose sign denotes the result:"
{ $list
    { "positive - indicates that " { $snippet "elt1" } " follows " { $snippet "elt2" } }
    { "zero - indicates that " { $snippet "elt1" } " is ordered equivalently to " { $snippet "elt2" } }
    { "negative - indicates that " { $snippet "elt1" } " precedes " { $snippet "elt2" } }
}
"Sorting a sequence with a custom comparator:"
{ $subsection sort }
"Sorting a sequence with common comparators:"
{ $subsection natural-sort }
{ $subsection sort-keys }
{ $subsection sort-values }
"Binary search:"
{ $subsection binsearch }
{ $subsection binsearch* } ;

ARTICLE: "sequences-unsafe" "Unsafe sequence operations"
"The unsafe sequence protocol bypasses bounds checks for increased performance:"
{ $subsection nth-unsafe }
{ $subsection set-nth-unsafe }
"These words assume the sequence index given is within bounds; if it is not, memory corruption can occur. Please think twice before using them; first, make sure the code in question is actually a bottleneck; next, try improving the algorithm first. If all else fails, then use these words and test your code very carefully."
$nl
"There is a very important invariant these word must preserve: if at some point in time, the length of a sequence was " { $snippet "n" } ", then any future lookups of elements with indices below " { $snippet "n" } " must not crash the runtime, even if the sequence length is now less than " { $snippet "n" } ". For example, vectors preserve this invariant by never shrinking the underlying storage, only growing it as necessary."
$nl
"The justification for this is that the runtime should not crash if a resizable sequence is resized during the execution of an iteration combinator."
$nl
"Indeed, iteration combinators are the primary use-case for these words; if the iteration index is already guarded by a loop test which ensures it is within bounds, then additional bounds checks are redundant. For example, see the implementation of " { $link each } "." ;

ARTICLE: "sequences-resizable" "Resizable sequence implementation"
"Resizable sequences are implementing by having a wrapper object hold a reference to an underlying sequence, together with a fill pointer indicating how many elements of the underlying sequence are occupied. When the fill pointer exceeds the underlying sequence capacity, the underlying sequence grows."
$nl
"There is a resizable sequence protocol:"
{ $subsection underlying }
{ $subsection set-underlying }
{ $subsection set-fill }
"Any instance of a class implementing the above generics can make use of several utility words:"
{ $subsection capacity }
{ $subsection ensure }
{ $subsection grow-length }
{ $subsection clone-resizable }
"This protocol and the above words are unsafe; they do not perform bounds checks for performance reasons, and thus a mistake can lead to memory corruption due to an underlying sequence being shorter than the fill pointer."
$nl
"Vectors and string buffers are implemented using the resizable sequence facility (and they perform full bounds-checks and thus are safe)." ;

ARTICLE: "sequences" "Sequences"
"A sequence is a finite, linearly-ordered collection of elements."
$nl
"Sequence utility words can operate on any object whose class implements the sequence protocol."
{ $subsection "sequence-protocol" }
"There are a number of implementations of sequences in the core library, and you can write new implementations yourself."
{ $subsection "sequence-implementations" }
"Much of the power of sequences lies in the polymorphic utility words that allow computations to be expressed as bulk operations without loops, recursion or micro-management of elements."
{ $subsection "sequences-access" }
{ $subsection "sequences-combinators" }
{ $subsection "sequences-tests" }
{ $subsection "sequences-search" }
{ $subsection "sequences-add-remove" }
{ $subsection "sequences-join-split" }
{ $subsection "sequences-reshape" }
{ $subsection "sequences-comparing" }
{ $subsection "sequences-sorting" }
{ $subsection "sequences-destructive" }
"Sequences are also used to implement other data structures:"
{ $subsection "sequences-stacks" }
"Some implementation details which your code should probably not care about:"
{ $subsection "sequences-unsafe" }
{ $subsection "sequences-resizable" }
{ $see-also "namespaces-make" "assocs-alists" } ;
