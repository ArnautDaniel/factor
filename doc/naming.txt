FACTOR CODING CONVENTIONS.

=== Naming words

foo.     - perform "foo", but instead of pushing the result on the
           stack, print it in a human-readable form suitable for
	   interactive use.

	   Eg: words. vocabs.

.X       - four words to print the contents of the stacks:
           .s - data stack
	   .r - call stack
	   .n - name stack
	   .c - catch stack

foo*     - a variation of "foo" that takes more parameters.

           Eg: index-of* parse* random-element*

         - a lower-level word used in the implementation of "foo".

	   Eg: compile* prettyprint*

         - a word that is a variation on "foo", but is more specialized
	   and less frequently used.

	   Eg: last* get*

(foo)    - a word that is only useful in the implementation of "foo".

           Eg: (vector=) (split)

>to    - convert object to type "to".

           Eg: >str >lower >upper >fixnum >realnum

	 - move top of data stack "to" stack.
	 
	   Eg: >r >n >c

from>    - convert object from type "from".

           Eg: dec> oct> hex>

         - move top of "from" stack to data stack.
	 
	   Eg: r> n> c>

one>two  - convert object of type "one" to "two".

           Eg: stream>str stack>list worddef>list

         - transfer values between stacks.
	 
	   Eg: >r r> 2>r 2r> >n

<type>   - create an object of "type".

           Eg: <namespace> <sbuf> <stream>

foo@     - get the value of a variable at the top of the stack;
           operate on the value with "foo"; store the value back in the
	   variable.

	   Eg: +@ *@ -@ /@ cons@ append@

foo-iter - a tail-recursive word used in the implementatin of "foo".

           Eg: nreverse-iter partition-iter

nfoo     - on lists, a destructive (non-consing) version of "foo".

           Eg: nappend nreverse

2foo     - like foo but with two operands taken from stack.

           Eg: 2drop 2dup 2each
