% :indentSize=4:tabSize=4:noTabs=true:mode=tex:wrap=soft:

\documentclass{book}

\usepackage[plainpages=false,colorlinks]{hyperref}
\usepackage[style=list,toc]{glossary}
\usepackage{alltt}
\usepackage{times}
\usepackage{tabularx}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{epstopdf}

\pagestyle{headings}

\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}

\newcommand{\bs}{\char'134}
\newcommand{\dq}{\char'42}
\newcommand{\tto}{\symbol{123}}
\newcommand{\ttc}{\symbol{125}}
\newcommand{\pound}{\char'43}

\newcommand{\vocabulary}[1]{\emph{Vocabulary:} \texttt{#1}&\\}

\newcommand{\parsingword}[2]{\index{\texttt{#1}}\emph{Parsing word:} \texttt{#2}&\\}

\newcommand{\ordinaryword}[2]{\index{\texttt{#1}}\emph{Word:} \texttt{#2}&\\}

\newcommand{\symbolword}[1]{\index{\texttt{#1}}\emph{Symbol:} \texttt{#1}&\\}

\newcommand{\classword}[1]{\index{\texttt{#1}}\emph{Class:} \texttt{#1}&\\}

\newcommand{\genericword}[2]{\index{\texttt{#1}}\emph{Generic word:} \texttt{#2}&\\}

\newcommand{\predword}[1]{\ordinaryword{#1}{#1~( object -- ?~)}}

\setlength{\tabcolsep}{1mm}

\newcommand{\wordtable}[1]{

\begin{tabularx}{12cm}[t]{lX}
\hline
#1
\hline
\end{tabularx}

}

\makeatletter

\makeatother

\makeglossary
\makeindex

\begin{document}

\title{Factor Developer's Handbook}

\author{Slava Pestov}

\maketitle
\tableofcontents{}

\chapter*{Preface}

What follows is a detailed guide to the Factor language and development environment. It is not a tutorial or introductory guide, nor does it cover some background material that you are expected to understand, such as object-oriented programming, higher-order functions, continuations, or general issues of algorithm and program design.

Factor is a programming language combinding a postfix syntax with a functional and object-oriented
flavor, building on ideas from Forth, Joy and Lisp.

Factor is \emph{dynamic}. This means that all objects in the language are fully reflective at run time, and that new definitions can be entered without restarting the runtime. Factor code can be used interchangably as data, meaning that sophisticated language extensions can be realized as libraries of words.

Factor is \emph{safe}. This means all code executes in an object-oriented runtime that provides
garbage collection and prohibits direct pointer arithmetic. There is no way to get a dangling reference by deallocating a live object, and it is not possible to corrupt memory by overwriting the bounds of an array.

\chapter{Language reference}

\section{Conventions}

When examples of interpreter interactions are given in this guide, the input is in a roman font, and any
output from the interpreter is in boldface:
\begin{alltt}
\textbf{ok} "Hello, world!" print
\textbf{Hello, world!}
\end{alltt}

\subsection{Word definitions}

Parsing words, defined in \ref{parser}, are presented with the following notation.
\wordtable{
\vocabulary{foo}
\parsingword{word}{word syntax...}
}
The parsing word's name is followed by the syntax, with meta-syntactic variables set in an italic font. For example:
\wordtable{
\vocabulary{syntax}
\parsingword{colon}{:~\emph{name} \emph{definition} ;}
}
Ordinary words are presented in the following notation.
\wordtable{
\vocabulary{foo}
\ordinaryword{word}{word ( \emph{inputs} -- \emph{outputs} )}
}
A compound definition in the library, or primitive in the runtime.
\wordtable{
\vocabulary{foo}
\symbolword{word}
}
A symbol definition.
\wordtable{
\vocabulary{foo}
\genericword{word}{word ( \emph{inputs} -- \emph{outputs} )}
}
A generic word definition.
\wordtable{
\vocabulary{foo}
\classword{word}
}
A class that generic word methods can specialize on.

\subsection{Stack effects}

Within a stack effect comment, the top of the stack is the rightmost entry in both the
list of inputs and outputs, so \texttt{( x y -- x-y )} indicates that the top stack element will be subtracted from the element underneath.

The following abbreviations have conventional meaning in stack effect comments:

\begin{description}
\item[\texttt{[ x y z ]}] a list with elements whose types are hinted at by \texttt{x}, \texttt{y}, \texttt{z}
\item[\texttt{[[ x y ]]}] a cons cell where the type of the cdr is hinted at by \texttt{x}, and the type of the cdr is hinted at by \texttt{y}
\item[\texttt{ch}] an integer representing a Unicode character
\item[\texttt{elt}] an arbitrary object that happends to be an element of a collection
\item[\texttt{i}] a loop counter or index
\item[\texttt{j}] a loop counter or index
\item[\texttt{n}] a number
\item[\texttt{obj}] an arbitrary object
\item[\texttt{quot}] a quotation
\item[\texttt{seq}] a sequence
\item[\texttt{str}] a string
\item[\texttt{path}] a string representing a file's path name
\item[\texttt{?}] a boolean
\item[\texttt{foo/bar}] either \texttt{foo} or \texttt{bar}. For example, \texttt{str/f} means either a string, or \texttt{f}
\end{description}

If the stack effect identifies quotations, the stack effect of each quotation may be given after suffixing \texttt{|} to the whole string. For example, the following denotes a word that takes a list and a quotation and produces a new list, calling the quotation with elements of the list.
\begin{verbatim}
( list quot -- list | quot: elt -- elt )
\end{verbatim}

\subsection{Naming conventions}

The following naming conventions are used in the Factor library.

\begin{description}
\item[\texttt{FOO:}] a parsing word that reads ahead from the input string
\item[\texttt{FOO}] a parsing word that does not read ahead, but rather takes a fixed action at parse time
\item[\texttt{FOO"}] a parsing word that reads characters from the input string until the next occurrence of \texttt{"}
\item[\texttt{foo?}] a predicate returning a boolean or generalized boolean value
\item[\texttt{foo.}] a word whose primary action is to print something, rather than to return a value. The basic case is the \texttt{.}~word, which prints the object at the top of the stack
\item[\texttt{foo*}] a variation of the \texttt{foo} word that takes more parameters
\item[\texttt{(foo)}] a word that is only useful for the implementation of \texttt{foo}
\item[\texttt{>to}] converts the object at the top of the stack to the \texttt{to} class
\item[\texttt{from>}] converts an instance of the \texttt{from} class into some canonical form
\item[\texttt{from>to}] convert an instance of the \texttt{from} class to the \texttt{to} class
\item[\texttt{>s}] move top of data stack to the \texttt{s} stack, where \texttt{s} is either \texttt{r} (call stack), \texttt{n} (name stack), or \texttt{c} (catch stack). Sometimes, libraries will define their own words following this naming convention, to implement user-defined stacks, typically stored in variables
\item[\texttt{s>}] move top of \texttt{s} stack to the data stack, where \texttt{s} is as above
\item[\texttt{<class>}] create a new instance of \texttt{class}
\item[\texttt{nfoo}] destructive version of \texttt{foo}, that modifies one of its inputs rather than returning a new value. The ``n'' prefix denotes ``non-constructive''. This convention is used by sequence words
\item[\texttt{2foo}] like \texttt{foo} but takes or returns two operands
\item[\texttt{3foo}] like \texttt{foo} but takes or returns three operands
\item[\texttt{foo-with}] a form of the \texttt{foo} combinator that takes an extra object, and passes this object on each iteration of the quotation; for example, \texttt{each-with} and \texttt{map-with}
\item[\texttt{with-foo}] executes a quotation in a namespace where \texttt{foo} is configured in a special manner; for example, \texttt{with-stream}
\item[\texttt{make-foo}] executes a quotation in a namespace where a sequence of type \texttt{foo} is being constructed; for example, \texttt{make-string}
\end{description}

\subsection{Mathematics}

This guide uses the standard mathematical notation to denote intervals.

\begin{tabular}{l|l}
Notation&Meaning\\
\hline
$(a,b)$&All numbers from $a$ to $b$, excluding $a$ and $b$\\
$[a,b)$&All numbers from $a$ to $b$, including $a$ and excluding and $b$\\
$(a,b]$&All numbers from $a$ to $b$, excluding $a$ and including and $b$\\
$[a,b]$&All numbers from $a$ to $b$, including $a$ and $b$
\end{tabular}

\section{\label{syntax}Syntax}
\newcommand{\parseglos}{\glossary{name=parser,
description={a set of words in the \texttt{parser} vocabulary, primarily \texttt{parse}, \texttt{eval}, \texttt{parse-file} and \texttt{run-file}, that creates objects from their printed representations, and adds word definitions to the dictionary}}}
\parseglos
In Factor, an \emph{object} is a piece of data that can be identified. Code is data, so Factor syntax is actually a syntax for describing objects, of which code is a special case. Factor syntax is read by the parser. The parser performs two kinds of tasks -- it creates objects from their \emph{printed representations}, and it adds \emph{word definitions} to the dictionary. The latter is discussed in \ref{words}. The parser can be extended (\ref{parser}).

\subsection{\label{parser}Parser algorithm}

\parseglos
\glossary{name=token,
description={a whitespace-delimited piece of text, the primary unit of Factor syntax}}
\glossary{name=whitespace,
description={a space (ASCII 32), newline (ASCII 10) or carriage-return (ASCII 13)}}

\begin{figure}
\caption{Parser algorithm}
\begin{center}
\scalebox{0.40}{\epsfig{file=parser.eps}}
\end{center}
\end{figure}

At the most abstract level,
Factor syntax consists of whitespace-separated tokens. The parser tokenizes the input on whitespace boundaries, where whitespace is defined as a sequence or one or more space, tab, newline or carriage-return characters.  The parser is case-sensitive, so
the following three expressions tokenize differently:
\begin{verbatim}
2X+
2 X +
2 x +
\end{verbatim}
As the parser reads tokens it makes a distinction between numbers, ordinary words, and
parsing words. Tokens are appended to the parse tree, the top level of which is a list
returned by the original parser invocation. Nested levels of the parse tree are created
by parsing words.

Here is the parser algorithm in more detail -- some of the concepts therein will be defined shortly:

\begin{itemize}
\item If the current character is a double-quote (\texttt{"}), the \texttt{"} parsing word is executed, causing a string to be read.
\item Otherwise, the next token is taken from the input. The parser searches for a word named by the token in the currently used set of vocabularies. If the word is found, one of the following two actions is taken:
\begin{itemize}
\item If the word is an ordinary word, it is appended to the parse tree.
\item If the word is a parsing word, it is executed.
\end{itemize}
Otherwise if the token does not represent a known word, the parser attempts to parse it as a number. If the token is a number, the number object is added to the parse tree. Otherwise, an error is raised and parsing halts.
\end{itemize}

\newcommand{\stringmodeglos}{
\glossary{name=string mode,
description={a parser mode where token are added to the parse tree as strings, without being looked up in the dictionary or converted into numbers first. Activated by switching on the \texttt{string-mode} variable}}}
\stringmodeglos

There is one exception to the above process; the parser might be placed in \emph{string mode}, in which case it simply reads tokens and appends them to the parse tree as strings. String mode is activated and deactivated by certain parsing words wishing to read input in an unstructured but tokenized manner -- see \ref{string-mode}.

\newcommand{\parsingwordglos}{
\glossary{name=parsing word,
description={a word that is run at parse time. Parsing words can be defined by suffixing the compound definition with \texttt{parsing}. Parsing words have the \texttt{\dq{}parsing\dq{}} word property set to true, and respond with true to the \texttt{parsing?}~word}}}
\parsingwordglos

Parsing words play a key role in parsing; while ordinary words and numbers are simply
added to the parse tree, parsing words execute in the context of the parser, and can
do their own parsing and create nested data structures in the parse tree. Parsing words
are also able to define new words.

While parsing words supporting arbitrary syntax can be defined, the default set is found
in the \texttt{syntax} vocabulary and provides the basis for all further syntactic
interaction with Factor.

\subsection{\label{vocabsearch}Vocabulary search}

\newcommand{\wordglos}{\glossary{
name=word,
description={an object holding a code definition and set of properties. Words are organized into vocabularies, and are uniquely identified by name within a vocabulary.}}}
\wordglos
\newcommand{\vocabglos}{\glossary{
name=vocabulary,
description={a collection of words, uniquely identified by name. The hashtable of vocabularies is stored in the \texttt{vocabularies} global variable, and the \texttt{USE:}~and \texttt{USING:}~parsing words add vocabularies to the parser's search path}}}
\vocabglos

A \emph{word} is a code definition identified by a name. Words are sorted into \emph{vocabularies}. Words are discussed in depth in \ref{words}.

When the parser reads a token, it attempts to look up a word named by that token. The
lookup is performed in the parser's current vocabulary set.

For a source file the vocabulary search path starts off with two vocabularies:
\begin{verbatim}
syntax
scratchpad
\end{verbatim}
The \texttt{syntax} vocabulary consists of a set of parsing words for reading Factor data
and defining new words. The \texttt{scratchpad} vocabulary is the default vocabulary for new
word definitions.

At the interactive listener, the default search path contains many more vocabularies. The default search path depends on how the parser was invoked (\ref{parsing-quotations}).
\wordtable{
\vocabulary{syntax}
\parsingword{USE:}{USE: \emph{vocabulary}}
}
\newcommand{\useglos}{\glossary{
name=search path,
description={the list of vocabularies that the parser looks up tokens in. You can add to this list with the \texttt{USE:} and \texttt{USING:} parsing words}}}
\useglos

The \texttt{USE:} parsing word adds a new vocabulary at the front of the search path. Subsequent word lookups by the parser will search this vocabulary first.
\begin{alltt}
USE: lists
\end{alltt}
\wordtable{
\vocabulary{syntax}
\parsingword{USING:}{USING: \emph{vocabularies} ;}
}
Consecutive \texttt{USE:} declarations can be merged into a single \texttt{USING:} declaration.
\begin{alltt}
USING: lists strings vectors ;
\end{alltt}

Due to the way the parser works, words cannot be referenced before they are defined; that is, source files must order definitions in a strictly bottom-up fashion. For a way around this, see \ref{deferred}.

\subsection{Numbers}

\newcommand{\numberglos}{\glossary{
name=number,
description={an instance of the \texttt{number} class}}}
\numberglos

If a vocabulary lookup of a token fails, the parser attempts to parse it as a number.

\subsubsection{\label{integer-literals}Integers}

\newcommand{\integerglos}{\glossary{
name=integer,
description={an instance of the \texttt{integer} class, which is a disjoint union of the \texttt{fixnum} and \texttt{bignum} classes}}}
\numberglos

\newcommand{\fixnumglos}{\glossary{
name=fixnum,
description={an instance of the \texttt{fixnum} class, representing a fixed precision integer. On 32-bit systems, an element of the interval $(-2^{-29},2^{29}]$, and on 64-bit systems, the interval $(-2^{-61},2^{61}]$}}}
\fixnumglos

\newcommand{\bignumglos}{\glossary{
name=bignum,
description={an instance of the \texttt{bignum} class, representing an arbitrary-precision integer whose value is bounded by available object memory}}}
\bignumglos

The printed representation of an integer consists of a sequence of digits, optionally prefixed by a sign.
\begin{alltt}
123456
-10
2432902008176640000
\end{alltt}
Integers are entered in base 10 unless prefixed with a base change parsing word.
\wordtable{
\vocabulary{syntax}
\parsingword{BIN:}{BIN: \emph{integer}}
\parsingword{OCT:}{OCT: \emph{integer}}
\parsingword{HEX:}{HEX: \emph{integer}}
}
\begin{alltt}
\textbf{ok} BIN: 1110 BIN: 1 + .
\textbf{15}
\textbf{ok} HEX: deadbeef 2 * .
\textbf{7471857118}
\end{alltt}

More information on integers can be found in \ref{integers}.

\subsubsection{\label{ratio-literals}Ratios}

\newcommand{\ratioglos}{\glossary{
name=ratio,
description={an instance of the \texttt{ratio} class, representing an exact ratio of two integers}}}
\ratioglos

The printed representation of a ratio is a pair of integers separated by a slash (\texttt{/}).
No intermediate whitespace is permitted. Either integer may be signed, however the ratio will be normalized into a form where the denominator is positive and the greatest common divisor
of the two terms is 1.
\begin{alltt}
75/33
1/10
-5/-6
\end{alltt}

More information on ratios can be found in \ref{ratios}.

\subsubsection{\label{float-literals}Floats}

\newcommand{\floatglos}{\glossary{
name=float,
description={an instance of the \texttt{float} class, representing an IEEE 754 double-precision floating point number}}}
\floatglos

Floating point numbers contain an optional decimal part, an optional exponent, with
an optional sign prefix on either the significand or exponent.
\begin{alltt}
10.5
-3.1456
7e13
1e-5
\end{alltt}

More information on floats can be found in \ref{floats}.

\subsubsection{\label{complex-literals}Complex numbers}

\newcommand{\complexglos}{\glossary{
name=complex,
description={an instance of the \texttt{complex} class, representing a complex number with real and imaginary components, where both components are real numbers}}}
\complexglos
\wordtable{
\vocabulary{syntax}
\parsingword{\pound\tto}{\#\tto{} \emph{real} \emph{imaginary} \ttc\#}
}
A complex number
is given by two components, a ``real'' part and ''imaginary'' part. The components
must either be integers, ratios or floats.
\begin{verbatim}
#{ 1/2 1/3 }#   ! the complex number 1/2+1/3i
#{ 0 1 }#       ! the imaginary unit
\end{verbatim}

More information on complex numbers can be found in \ref{complex-numbers}.

\subsection{Literals}

Many different types of objects can be constructed at parse time via literal syntax. Numbers are a special case since support for reading them is built-in to the parser. All other literals are constructed via parsing words.

If a quotation contains a literal object, the same literal object instance is used each time the quotation executes; that is, literals are ``live''.

\subsubsection{\label{boolean}Booleans}

\newcommand{\boolglos}{
\glossary{
name=boolean,
description={an instance of the \texttt{boolean} class, either \texttt{f} or \texttt{t}. See generalized boolean}}
\glossary{
name=generalized boolean,
description={an object used as a truth value. The \texttt{f} object is false and anything else is true. See boolean}}
\glossary{
name=t,
description={the canonical truth value. The \texttt{t} class, whose sole instance is the \texttt{t} object. Note that the \texttt{t} class is not equal to the \texttt{t} object}}
\glossary{
name=f,
description={the canonical false value; anything else is true. The \texttt{f} class, whose sole instance is the \texttt{f} object. Note that the \texttt{f} class is not equal to the \texttt{f} object}}
}
\boolglos
Any Factor object may be used as a truth value in a conditional expression. The \texttt{f} object is false and anything else is true. The \texttt{f} object is also used to represent the empty list, as well as the concept of a missing value. The canonical truth value is the \texttt{t} object.
\wordtable{
\vocabulary{syntax}
\parsingword{f}{f}
\parsingword{t}{t}
}
Adds the \texttt{f} and \texttt{t} objects to the parse tree.

Note that the \texttt{f} parsing word and class is not the same as the \texttt{f} object. The former can be obtained by writing \texttt{\bs~f} inside a quotation, or \texttt{POSTPONE: f} inside a list that will not be evaluated.
\begin{alltt}
\textbf{ok} f \bs f = .
\textbf{f}
\end{alltt}
An analogous distinction holds for the \texttt{t} class and object.

\subsubsection{\label{syntax:char}Characters}

\newcommand{\charglos}{\glossary{
name=character,
description={an integer whose value denotes a Unicode code point. Character values are limited to the range from $0$ to $2^{16}-1$ inclusive, however in a later release this can be upgraded to the full 21-bit Unicode space without requiring any changes to user code}}}
\charglos
Factor has no distinct character type, however Unicode character value integers can be
read by specifying a literal character, or an escaped representation thereof.
\wordtable{
\vocabulary{syntax}
\parsingword{CHAR:}{CHAR: \emph{token}}
}
Adds the Unicode code point of the character represented by \emph{token} to the parse tree.

\newcommand{\escapeglos}{\glossary{
name=escape,
description={a sequence allowing a non-literal character to be inserted in a string. For a list of escapes, see \ref{escape}}}}
\escapeglos
If the token is a single-character string other than whitespace or backslash, the character is taken to be this token. If the token begins with a backslash, it denotes one of the following escape codes.
\begin{table}[Special character escape codes]
\label{escape}
\begin{tabular}{l|l}
Escape code&Character\\
\hline
\texttt{\bs{}\bs}&Backslash (\texttt{\bs})\\
\texttt{\bs{}s}&Space\\
\texttt{\bs{}t}&Tab\\
\texttt{\bs{}n}&Newline\\
\texttt{\bs{}t}&Carriage return\\
\texttt{\bs{}0}&Null byte (ASCII 0)\\
\texttt{\bs{}e}&Escape (ASCII 27)\\
\texttt{\bs{}"}&Double quote (\texttt{"})\\
\end{tabular}
\end{table}
Examples:
\begin{alltt}
\textbf{ok} CHAR: a .
\textbf{97}
\textbf{ok} CHAR: \bs{}0 .
\textbf{0}
\textbf{ok} CHAR: \bs{}n .
\textbf{10}
\end{alltt}
A Unicode character can be specified by its code number by writing \texttt{\bs{}u} followed by a four-digit hexadecimal. That is, the following two expressions are equivalent:
\begin{alltt}
CHAR: \bs{}u0078
78
\end{alltt}
While not useful for single characters, this syntax is also permitted inside strings.

\subsubsection{\label{string-literals}Strings}

\newcommand{\stringglos}{\glossary{
name=string,
description={an instance of the \texttt{string} class, representing an immutable sequence of characters}}}
\stringglos
\wordtable{
\vocabulary{syntax}
\parsingword{"}{"\emph{string}"}
}
Reads from the input string until the next occurrence of
\texttt{"}, and appends the resulting string to the parse tree. String literals cannot span multiple lines.
Strings containing
the \texttt{"} character and various other special characters can be read by
inserting escape sequences as described in \ref{syntax:char}.
\begin{alltt}
\textbf{ok} "Hello world" print
\textbf{Hello world}
\end{alltt}

Strings are documented in \ref{strings}.

\subsubsection{\label{listsyntax}Lists}
\newcommand{\listglos}{\glossary{
name=list,
description={an instance of the \texttt{list} class, storing a sequence of elements as a chain of zero or more conses, where the car of each cons is an element, and the cdr is either \texttt{f} or another list}}
\glossary{name=proper list, description=see list}
}
\listglos
\wordtable{
\vocabulary{syntax}
\parsingword{[}{[}
\parsingword{]}{]}
}
Parses a list, whose elements are read between \texttt{[} and \texttt{]} and can include other lists.
\begin{verbatim}
[
    "404" "responder" set
    [ drop no-such-responder ] "get" set
]
\end{verbatim}
\newcommand{\consglos}{\glossary{
name=cons,
description={an instance of the \texttt{cons} class, storing an ordered pair of objects referred to as the car and the cdr}}}
\consglos
\wordtable{
\vocabulary{syntax}
\parsingword{[[}{[[ \emph{car} \emph{cdr} ]]}
}
Parses two components making up a cons cell. Note that the lists parsed with \texttt{[} and \texttt{]} are just a special case of \texttt{[[} and \texttt{]]}. The following two lines are equivalent.
\begin{alltt}
[ 1 2 3 ]
[[ 1 [[ 2 [[ 3 f ]] ]] ]]
\end{alltt}
The empty list is denoted by \texttt{f}, along with boolean falsity, and the concept of a missing value. The expression \texttt{[ ]} parses to the same object as \texttt{f}.

Lists are documented in \ref{lists}.

\subsubsection{Words}

While words parse as themselves, a word occurring inside a quotation is executed when the quotation is called. Sometimes it is desirable to have a word be pushed on the data stack during the execution of a quotation, usually for reflective access to the word's slots.
\wordtable{
\vocabulary{syntax}
\parsingword{\bs}{\bs~\emph{word}}
}
Reads the next word from the input string and appends some \emph{code} to the parse tree that pushes the word on the stack when the code is called. The following two lines are equivalent:
\begin{verbatim}
\ length
[ length ] car
\end{verbatim}
\wordtable{
\vocabulary{syntax}
\parsingword{POSTPONE:}{POSTPONE: \emph{word}}
}
Reads the next word from the input string and appends the word to the parse tree, even if it is a parsing word. For an word \texttt{foo}, \texttt{POSTPONE: foo} and \texttt{foo} are equivalent; however, if \texttt{foo} is a parsing word, the latter will execute it at parse time, while the former will execute it at runtime. Usually used inside parsing words that wish to delegate some action to a further parsing word.
\begin{alltt}
\textbf{ok} : parsing1
    "Parsing 1" print 2 swons ; parsing
\textbf{ok} : parsing2
    "Parsing 2" print POSTPONE: parsing1 ; parsing
\textbf{ok} [ 1 parsing1 3 ] .
\textbf{Parsing 1}
\textbf{[ 1 2 3 ]}
\textbf{ok} [ 0 parsing2 2 4 ] .
\textbf{Parsing 2}
\textbf{Parsing 1}
\textbf{[ 0 2 4 ]}
\end{alltt}

Words are documented in \ref{words}.
Parsing words are documented in \ref{parsing-words}.

\subsubsection{Mutable literals}

\newcommand{\mutableglos}{\glossary{name=mutable object,
description=an object whose slot values can be changed}
\glossary{name=immutable object,
description=an object whose slot values cannot be changed}}
\mutableglos

Using mutable object literals in word definitions requires care, since if those objects
are mutated, the actual word definition will be changed, which is in most cases not what you would expect. Strings and lists are immutable; string buffers, vectors, hashtables and tuples are mutable.

\subsubsection{\label{sbuf-literals}String buffers}

\newcommand{\sbufglos}{\glossary{
name=string buffer,
description={an instance of the \texttt{sbuf} class, representing a mutable and growable sequence of characters}}
\glossary{name=sbuf, description=see string buffer}}
\sbufglos
\wordtable{
\vocabulary{syntax}
\parsingword{SBUF"}{SBUF" \emph{text}"}
}
Reads from the input string until the next occurrence of
\texttt{"}, converts the string to a string buffer, and appends it to the parse tree.
As with strings, the escape codes described in \ref{syntax:char} are permitted.
\begin{alltt}
\textbf{ok} SBUF" Hello world" sbuf>string print
\textbf{Hello world}
\end{alltt}

String buffers are documented in \ref{string-buffers}.

\subsubsection{\label{vector-literals}Vectors}
\newcommand{\vectorglos}{\glossary{
name=vector,
description={an instance of the \texttt{vector} class, storing a mutable and growable sequence of elements in a contiguous range of memory}}}
\vectorglos
\wordtable{
\vocabulary{syntax}
\parsingword{\tto}{\tto}
\parsingword{\ttc}{\ttc}
}
Parses a vector, whose elements are read between \texttt{\tto} and \texttt{\ttc}.
\begin{verbatim}
{ 3 "blind" "mice" }
\end{verbatim}

Vectors are documented in \ref{vectors}.

\subsubsection{Hashtables}
\newcommand{\hashglos}{\glossary{
name=hashtable,
description={an instance of the \texttt{hashtable} class, providing a mutable mapping of keys to values}}}
\hashglos
\wordtable{
\vocabulary{syntax}
\parsingword{\tto\tto}{\tto\tto}
\parsingword{\ttc\ttc}{\ttc\ttc}
}
Parses a hashtable. Elements between \texttt{\tto\tto} and \texttt{\ttc\ttc} must be cons cells, where the car is the key and the cdr is a value.
\begin{verbatim}
{{
    [[ "red" [ 255 0 0 ] ]]
    [[ "green" [ 0 255 0 ] ]]
    [[ "blue" [ 0 0 255 ] ]]
}}
\end{verbatim}

Hashtables are documented in \ref{hashtables}.

\subsubsection{Tuples}
\newcommand{\tupleglos}{\glossary{
name=tuple,
description={an instance of a user-defined class whose metaclass is the \texttt{tuple} metaclass, storing a fixed set of elements in named slots, with optional delegation method dispatch semantics}}}
\tupleglos
\wordtable{
\vocabulary{syntax}
\parsingword{<<}{<<}
\parsingword{>>}{>>}
}
Parses a tuple. The tuple's class must follow \texttt{<<}. The element after that is always the tuple's delegate. Further elements until \texttt{>>} are specified according to the tuple's slot definition, and an error is raised if an incorrect number of elements is given.
\begin{verbatim}
<< color f 255 0 0 >>
\end{verbatim}

Tuples are documented in \ref{tuples}.

\subsection{\label{comments}Comments}

\wordtable{
\vocabulary{syntax}
\parsingword{!}{!~\emph{remainder of line}}
}
The remainder of the input line is ignored if an exclamation mark (\texttt{!}) is read.
\begin{alltt}
! Note that the sequence union does not include lists,
! or user defined tuples that respond to the sequence
! protocol.
\end{alltt}
\wordtable{
\vocabulary{syntax}
\parsingword{hash!}{\#!~\emph{remainder of line}}
}
\newcommand{\doccommentglos}{\glossary{
name=documentation comment,
description={a comment describing the usage of a word. Delimited by the \texttt{\#"!} parsing word, they appear at the start of a word definition and are stored in the \texttt{""documentation""} word property}}}
\doccommentglos
Comments that begin with \texttt{\#!} are called \emph{documentation comments}.
A documentation comment has no effect on the generated parse tree, but if it is the first thing inside a word definition, the comment text is appended to the string stored in the word's \texttt{"documentation"} property. 
\wordtable{
\vocabulary{syntax}
\parsingword{(}{( \emph{stack effect} )}
}
\glossary{
name=stack effect,
description={A string of the form \texttt{( \emph{inputs} -- \emph{outputs} )}, where the inputs and outputs are a whitespace-separated list of names or types. The top of the stack is the right-most token on both sides.}}
\newcommand{\stackcommentglos}{\glossary{
name=stack effect comment,
description={a comment describing the inputs and outputs of a word. Delimited by \texttt{(} and \texttt{}), they appear at the start of a word definition and are stored in the \texttt{""stack-effect""} word property}}}
\stackcommentglos
Comments delimited by \texttt{(} and \texttt{)} are called \emph{stack effect comments}. By convention they are placed at the beginning of a word definition to document the word's inputs and outputs:
\begin{verbatim}
: push ( element sequence -- )
    #! Push a value on the end of a sequence.
    dup length swap set-nth ;
\end{verbatim}
A stack effect comment has no effect on the generated parse tree, but if it is the first thing inside a word definition, the word's \texttt{"stack-effect"} property is set to the comment text.

Word properties are described in \ref{word-props}.

\section{Data and control flow}

\subsection{Shuffle words}

\newcommand{\dsglos}{\glossary{
name=stack,
description=see data stack}
\glossary{
name=data stack,
description={the primary means of passing values between words}}}
\dsglos
Shuffle words are placed between words taking action to rearrange items on the stack
as the next word in the quotation would expect them. Their behavior can be understood entirely in terms of their stack effects, which are given in table \ref{shuffles}.
\begin{table}
\caption{\label{shuffles}Shuffle words}
\wordtable{
\vocabulary{kernel}
\ordinaryword{drop}{drop ( x -- )}
\ordinaryword{2drop}{2drop ( x y -- )}
\ordinaryword{3drop}{3drop ( x y z -- )}
\ordinaryword{nip}{nip ( x y -- y )}
\ordinaryword{2nip}{2nip ( x y -- y )}
\ordinaryword{dup}{dup ( x -- x x )}
\ordinaryword{2dup}{2dup ( x y -- x y x y )}
\ordinaryword{3dup}{3dup ( x y z -- x y z x y z )}
\ordinaryword{dupd}{dupd ( x y -- x x y )}
\ordinaryword{over}{over ( x y -- x y x )}
\ordinaryword{pick}{pick ( x y z -- x y z x )}
\ordinaryword{tuck}{tuck ( x y -- y x y )}
\ordinaryword{swap}{swap ( x y -- y x )}
\ordinaryword{2swap}{2swap ( x y z t -- z t x y )}
\ordinaryword{swapd}{swapd ( x y z -- y x z )}
\ordinaryword{rot}{rot ( x y z -- y z x )}
\ordinaryword{-rot}{-rot ( x y z -- z x y )}
}
\end{table}

Try to avoid the complex shuffle words such as \texttt{rot} and \texttt{2dup} as much as possible, for they make data flow harder to understand. If you find yourself using too many shuffle words, or you're writing
a stack effect comment in the middle of a compound definition to keep track of stack contents, it is
a good sign that the word should probably be factored into two or
more smaller words.

\subsection{\label{quotations}Quotations}

\newcommand{\csglos}{\glossary{
name=return stack,
description=see call stack}
\glossary{
name=call stack,
description={holds quotations waiting to be called. When a quotation is called with \texttt{call}, or when a compound word is executed, the previous call frame is pushed on the call stack, and the new quotation becomes the current call frame}}}
\csglos
\newcommand{\cfglos}{\glossary{
name=call frame,
description=the currently executing quotation}}
\cfglos
\glossary{
name=interpreter,
description=executes quotations by iterating them and recursing into nested definitions. see compiler}

The Factor interpreter executes quotations. Quotations are lists, and since lists can contain any Factor object, they can contain words. It is words that give quotations their operational behavior, as you can see in the following description of the interpreter algorithm.

\begin{itemize}
\item If the call frame is \texttt{f}, the call stack is popped and becomes the new call frame.
\item If the car of the call frame is a word, the word is executed:
\begin{itemize}
\item If the word is a symbol, it is pushed on the data stack. See \ref{symbols}.
\item If the word is a compound definition, the current call frame is pushed on the call stack, and the new call frame becomes the word definition. See \ref{colondefs}.
\item If the word is compiled or primitive, the interpreter jumps to a machine code definition. See \ref{primitives}.
\item If the word is undefined, an error is raised. See \ref{deferred}.
\end{itemize}
\item Otherwise, the car of the call frame is pushed on the data stack.
\item The call frame is set to the cdr, and the loop continues.
\end{itemize}

\begin{figure}
\caption{Interpreter algorithm}
\begin{center}
\scalebox{0.45}{\epsfig{file=interpreter.eps}}
\end{center}
\end{figure}

The interpreter can be invoked reflectively with the following pair of words.
\wordtable{
\vocabulary{kernel}
\ordinaryword{call}{call ( quot -- )}
}
Push the current call frame on the call stack, and set the call stack to the given quotation. Conceptually: calls the quotation, as if its definition was substituted at the location of the \texttt{call}.
\begin{alltt}
\textbf{ok} [ 2 2 + 3 * ] call .
\textbf{12}
\end{alltt}
\wordtable{
\vocabulary{kernel}
\ordinaryword{execute}{execute ( word -- )}
}
Execute a word definition, taking action based on the word definition, as above.
\begin{alltt}
\textbf{ok} : hello "Hello world" print ;
\textbf{ok} : twice dup execute execute ;
\textbf{ok} \bs hello twice
\textbf{Hello world}
\textbf{Hello world}
\end{alltt}

\subsubsection{Tail call optimization}

\newcommand{\tailglos}{\glossary{
name=tail call,
description=the last call in a quotation}
\glossary{
name=tail call optimization,
description=the elimination of call stack pushes when making a tail call}}

When a call is made to a quotation from the last word in the call frame, there is no
purpose in pushing the empty call frame on the call stack. Therefore the last call in a quotation does not grow the call stack, and tail recursion executes in bounded space.

\subsubsection{Call stack manipulation}

Because of the way the interpreter is described in \ref{quotations}, the top of the call stack is not accessed during the execution of a quotation; it is only popped when the interpreter reaches the end of the quotation. In effect, the call stack can be used as a temporary storage area, as long as pushes and pops are balanced out within a single quotation.
\wordtable{
\vocabulary{kernel}
\ordinaryword{>r}{>r ( x -- r:x )}
}
Moves the top of the data stack to the call stack.
\wordtable{
\vocabulary{kernel}
\ordinaryword{r>}{r> ( x -- r:x )}
}
Moves the top of the call stack to the data stack.

The top of the data stack is ``hidden'' between \texttt{>r} and \texttt{r>}.
\begin{alltt}
\textbf{ok} 1 2 3 >r .s r>
\textbf{2
1}
\end{alltt}
It is very important to balance usages of \texttt{>r} and \texttt{r>} within a single quotation or word definition.
\begin{verbatim}
: the-good >r 2 + r> * ; ! Okay
: the-bad  >r 2 + ;      ! Runtime error
: the-ugly r> ;          ! Runtime error
\end{verbatim}
Basically, the rule is you must leave the call stack in the same state as you found it, so that when the current quotation finishes executing, the interpreter can return to the caller.

One exception is that when \texttt{ifte} occurs as the last word in a definition, values may be pushed on the call stack before the condition value is computed, as long as both branches of the \texttt{ifte} pop the values off the call stack before returning.
\begin{verbatim}
: foo ( m ? n -- m+n/n )
    >r [ r> + ] [ drop r> ] ifte ; ! Okay
\end{verbatim}

\subsubsection{Quotation variants}

There are three words that combine shuffle words with \texttt{call}. They are useful in the implementation of higher-order words taking quotations as inputs.
\wordtable{
\vocabulary{kernel}
\ordinaryword{slip}{slip ( quot x -- x | quot: -- )}
}
Call a quotation, while hiding the top of the stack. The implementation is as you would expect.
\begin{verbatim}
: slip ( quot x -- x | quot: -- )
    >r call r> ; inline
\end{verbatim}
\wordtable{
\vocabulary{kernel}
\ordinaryword{keep}{keep ( x quot -- x | quot:~x -- )}
}
Call a quotation with a value on the stack, restoring the value when the quotation returns.
\begin{verbatim}
: keep ( x quot -- x | quot: x -- )
    over >r call r> ; inline
\end{verbatim}
\wordtable{
\vocabulary{kernel}
\ordinaryword{2keep}{2keep ( x y q -- x y | q:~x y -- )}
}
Call a quotation with a pair of values on the stack, restoring the values when the quotation returns.
\begin{verbatim}
: 2keep ( x y quot -- x y | quot: x y -- )
    over >r pick >r call r> r> ; inline
\end{verbatim}

\subsection{Conditionals}

The simplest style of a conditional form is the \texttt{ifte} word.
\wordtable{
\vocabulary{kernel}
\ordinaryword{ifte}{ifte ( cond true false -- )}
}
The \texttt{cond} is a generalized boolean. If it is \texttt{f}, the \texttt{false} quotation is called, and if \texttt{cond} is any other value, the \texttt{true} quotation is called. The condition flag is removed from the stack before either quotation executes.

Note that in general, both branches should have the same stack effect. Not only is this good style that makes the word easier to understand, but also unbalanced conditionals cannot be compiled (\ref{compiler}).
\wordtable{
\vocabulary{kernel}
\ordinaryword{when}{when ( cond true -- | true:~-- )}
\ordinaryword{unless}{unless ( cond false -- | false:~-- )}
}
This pair are minor variations on \texttt{ifte} where only one branch is specified. The other is implicitly \texttt{[ ]}. They are implemented in the trivial way:
\begin{verbatim}
: when [ ] ifte ; inline
: unless [ ] swap ifte ; inline
\end{verbatim}
The \texttt{ifte} word removes the condition flag from the stack before calling either quotation. Sometimes this is not desirable, if the condition flag is serving a dual purpose as a value to be consumed by the \texttt{true} quotation. The \texttt{ifte*} word exists for this purpose.
\wordtable{
\vocabulary{kernel}
\ordinaryword{ifte*}{ifte*~( cond true false -- )}
\texttt{true:~cond --}\\
\texttt{false:~--}\\
}
If the condition is true, it is retained on the stack before the \texttt{true} quotation is called. Otherwise, the condition is removed from the stack and the \texttt{false} quotation is called. The following two lines are equivalent:
\begin{verbatim}
X [ Y ] [ Z ] ifte*
X dup [ Y ] [ drop Z ] ifte
\end{verbatim}
\wordtable{
\vocabulary{kernel}
\ordinaryword{when*}{when*~( cond true -- | true:~cond -- )}
\ordinaryword{unless*}{unless*~( cond false -- | false:~-- )}
}
These are variations of \texttt{ifte*} where one of the quotations is \texttt{[ ]}.

There is one final conditional form that is used to implement the ``default value'' idiom.
\wordtable{
\vocabulary{kernel}
\ordinaryword{?ifte}{?ifte ( default cond true false -- )}
\texttt{true:~cond --}\\
\texttt{false:~default --}\\
}
If the condition is \texttt{f}, the \texttt{false} quotation is called with the \texttt{default} value on the stack. Otherwise, the \texttt{true} quotation is called with the condition on the stack. The following two lines are equivalent:
\begin{verbatim}
X [ Y ] [ Z ] ?ifte
X dup [ nip Y ] [ drop Z ] ifte
\end{verbatim}

\subsubsection{Boolean logic}

The \texttt{?}~word chooses between two values, rather than two quotations.
\wordtable{
\vocabulary{kernel}
\ordinaryword{?}{?~( cond true false -- true/false )}
}
It is implemented in the obvious way.
\begin{verbatim}
: ? ( cond t f -- t/f )
    rot [ drop ] [ nip ] ifte ; inline
\end{verbatim}
Several words use \texttt{?}~to implement typical boolean algebraic operations.
\wordtable{
\vocabulary{kernel}
\ordinaryword{>boolean}{>boolean ( obj -- t/f )}
}
Convert a generalized boolean into a boolean. That is, \texttt{f} retains its value, whereas anything else becomes \texttt{t}.
\wordtable{
\vocabulary{kernel}
\ordinaryword{not}{not ( ?~-- ?~)}
}
Given \texttt{f}, outputs \texttt{t}, and on any other input, outputs \texttt{f}.
\wordtable{
\vocabulary{kernel}
\ordinaryword{and}{and ( ?~?~-- ?~)}
}
Outputs \texttt{t} if both of the inputs are true.
\wordtable{
\vocabulary{kernel}
\ordinaryword{or}{or ( ?~?~-- ?~)}
}
Outputs \texttt{t} if at least one of the inputs is true.
\wordtable{
\vocabulary{kernel}
\ordinaryword{xor}{xor ( ?~?~-- ?~)}
}
Outputs \texttt{t} if exactly one of the inputs is true.
\wordtable{
\vocabulary{kernel}
\ordinaryword{implies}{implies ( b1~b2~-- ?~)}
}
Outputs \texttt{t} if \texttt{b1} is false or both inputs are true.

An alternative set of logical operations operate on individual bits of integers bitwise, rather than generalized boolean truth values. They are documented in \ref{bitwise}.

\subsection{Continuations}

\newcommand{\contglos}{
\glossary{name=continuation,
description=an object representing the future of the computation}}
\contglos
At any point in the execution of a Factor program, the \emph{current continuation} represents the future of the computation. This object can be captured with the \texttt{callcc0} and \texttt{callcc1} words.
\wordtable{
\vocabulary{kernel}
\ordinaryword{callcc0}{callcc0 ( quot -- )}
\texttt{quot:~cont --}\\
\texttt{cont:~--}\\
\ordinaryword{callcc1}{callcc1 ( quot -- )}
\texttt{quot:~cont --}\\
\texttt{cont:~obj --}\\
}
Calling one of these words calls the given quotation with the continuation on the stack. The continuation is itself a quotation, and calling it \emph{continues execution} at the point after the call to \texttt{callcc0} and \texttt{callcc1}. Essentially, a continuation is a snapshot of the four stacks that can be restored at a later time.

The difference between \texttt{callcc0} and \texttt{callcc1} lies in the continuation object. When \texttt{callcc1} is used, calling the continuation takes one value from the top of the data stack, and places it back on the \emph{restored} data stack. This allows idioms such as exception handling, co-routines and generators to be implemented via continuations.

\subsubsection{\label{exceptions}Handling exceptional situations}
\glossary{name=exception,
description=an object representing an exceptional situation that has been detected}

Support for handling exceptional situations such as bad user input, implementation bugs, and input/output errors is provided by a pair of words, \texttt{throw} and \texttt{catch}.

\wordtable{
\vocabulary{errors}
\ordinaryword{throw}{throw ( exception -- )}
}
Raises an exception. Execution does not continue at the point after the \texttt{throw} call. Rather, the innermost catch block is invoked, and execution continues at that point. Passing \texttt{f} as an exception will cause \texttt{throw} to do nothing.
\wordtable{
\vocabulary{errors}
\ordinaryword{catch}{catch ( try handler -- )}
\texttt{handler:~exception/f -- }\\
}
An exception handler is established, and the \texttt{try} quotation is called.

If the \texttt{try} quotation throws an error and no nested \texttt{catch} is established, the following sequence of events takes place:
\begin{itemize}
\item the stacks are restored to their state prior to the \texttt{catch} call,
\item the exception is pushed on the data stack,
\item the \texttt{handler} quotation is called.
\end{itemize}
If the \texttt{try} quotation completes successfully, the stacks are \emph{not} restored. The \texttt{f} object is pushed, and the \texttt{handler} quotation is called.

A common idiom is that the \texttt{catch} block cleans up from the error in some fashion, then passes it on to the next-innermost catch block. The following word is used for this purpose.
\wordtable{
\vocabulary{errors}
\ordinaryword{rethrow}{rethrow ( exception -- )}
}
Raises an exception, without saving the current stacks for post-mortem inspection. This is done so that inspecting the error stacks sheds light on the original cause of the exception, rather than the point where it was rethrown.

Here is a simple example of a word definition that attempts to convert a string representing a hexadecimal number into an integer, and instead of halting execution when the string is not valid, it simply outputs \texttt{f}.
\begin{verbatim}
: catch-hex> ( str -- n/f )
    [ hex> ] [ [ drop f ] when ] catch ;
\end{verbatim}
Exception handling is implemented using a \emph{catch stack}. The \texttt{catch} word pushes the current continuation on the catch stack, and \texttt{throw} calls the continuation at the top of the catch stack with the raised exception.
\glossary{name=catch stack,
description={a stack of exception handler continuations, pushed and popped by \texttt{catch}}}

\begin{figure}
\caption{Exception handling example}
The following diagram illustrates the nesting of exception handlers on the catch stack immediately before the call to \texttt{throw} in \texttt{foe}.
\begin{verbatim}
: foe
    [
        "Fatal error -- hard disk on fire!" throw
    ] [
        "foe's catch block" print rethrow
    ] catch ;

: fie [ foe ] [ "fie's catch block" print rethrow ] catch ;
: flap [ fie ] [ [ "Exception: " write . ] when* ] catch ;
\end{verbatim}

\begin{center}
\scalebox{0.5}{\epsfig{file=catchstack.eps}}
\end{center}
\end{figure}

\subsubsection{\label{threads}Multitasking}

Factor implements co-operative multitasking, where the thread of control switches between tasks at explicit calls to \texttt{yield}, as well as when blocking I/O is performed. Multitasking is implemented via continuations.
\wordtable{
\vocabulary{threads}
\ordinaryword{in-thread}{in-thread ( quot -- )}

}
Calls \texttt{quot} in a co-operative thread. The new thread begins executing immediately, and the current thread resumes when the quotation yields, either from blocking
I/O or an explicit call to \texttt{yield}. This is implemented by adding the current continuation to the run queue, then calling \texttt{quot}, and finally executing \texttt{stop} after \texttt{quot} returns.
\wordtable{
\vocabulary{threads}
\ordinaryword{yield}{yield ( -- )}

}
Add the current continuation to the end of the run queue, and call the continuation at the front of the run queue.
\wordtable{
\vocabulary{threads}
\ordinaryword{stop}{stop ( -- )}

}
Call the continuation at the front of run queue, without saving the current continuation. In effect, this stops the current thread.

\subsubsection{Interpreter state}

The current state of the interpreter is determined by the contents of the four stacks. A set of words for getting and setting stack contents are the primitive building blocks for continuations, and in turn abstractions such as exception handling and multitasking.
\wordtable{
\vocabulary{kernel}
\ordinaryword{datastack}{datastack ( -- vector )}
\ordinaryword{set-datastack}{set-datastack ( vector -- )}

}
Save and restore the data stack contents. As an example, here is a word that executes a quotation and restores the data stack to its previous state;
\begin{verbatim}
: keep-datastack ( quot -- )
    datastack slip set-datastack drop ;
\end{verbatim}
Note that the \texttt{drop} call is made to remove the original quotation from the stack.
\wordtable{
\vocabulary{kernel}
\ordinaryword{callstack}{callstack ( -- vector )}
\ordinaryword{set-callstack}{set-callstack ( vector -- )}

}
Save and restore the call stack contents. The call stack does not include the currently executing quotation that made the call to \texttt{callstack}, since the current quotation is held in the call frame -- \ref{quotations} has details. Similarly, calling \texttt{set-callstack} will continue executing the current quotation until it returns, at which point control transfers to the quotation at the top of the new call stack.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{namestack}{namestack ( -- list )}
\\
\vocabulary{namespaces}
\ordinaryword{set-namestack}{set-namestack ( list -- )}

}
Save and restore the name stack, used for dynamic variable bindings. See \ref{namespaces}.
\wordtable{
\vocabulary{errors}
\ordinaryword{catchstack}{catchstack ( -- list )}
\\
\vocabulary{errors}
\ordinaryword{set-catchstack}{set-catchstack ( list -- )}

}
Save and restore the catch stack, used for exception handling. See \ref{exceptions}.

\section{\label{words}Words}

\wordglos
\vocabglos
\newcommand{\definingwordglos}{\glossary{name=defining word,
description=a word that adds definitions to the dictionary}}
\glossary{name=dictionary,
description=the collection of vocabularies making up the code in the Factor image}
\wordtable{
\vocabulary{words}
\classword{word}
}
Words are the fundamental unit of code in Factor, analogous to functions or procedures in other languages. Words are also objects, and this concept forms the basis for Factor's meta-programming facilities. Words hold two distinct pieces of information:
\begin{itemize}
\item A definition, specifying the behavior of the word when executed,
\item A set of word properties, including the name of the word, its vocabulary, any documentation strings, and other meta-data.
\end{itemize}
\wordtable{
\vocabulary{words}
\ordinaryword{word?}{word?~( object -- ?~)}
}
Tests if the \texttt{object} is a word.

\subsection{Vocabularies}
\wordtable{
\vocabulary{words}
\symbolword{vocabularies}
}
Words are organized into named vocabularies, stored in the global \texttt{vocabularies} variable (\ref{namespaces}).
\wordtable{
\vocabulary{syntax}
\parsingword{IN:}{IN:~\emph{vocabulary}}
}
Sets the current vocabulary for new word definitions, and adds the vocabulary to the search path (\ref{vocabsearch}).

Parsing words add definitions to the current vocabulary. When a source file is being parsed, the current vocabulary is initially set to \texttt{scratchpad}.

\subsubsection{Searching for words}

Words whose names are known at parse time -- that is, most words making up your program -- can be referenced by stating their name. However, the parser itself, and sometimes code you write, will need to look up words dynamically.
\wordtable{
\vocabulary{words}
\ordinaryword{search}{search ( name vocabs -- word )}

}
The \texttt{vocabs} parameter is a list of vocabulary names. If a word with the given name is found, it is pushed on the stack, otherwise, \texttt{f} is pushed.

\subsubsection{\label{creating-words}Creating words}

\wordtable{
\vocabulary{words}
\ordinaryword{create}{create ( name vocabulary -- word )}

}
Creates a new word \texttt{name} in \texttt{vocabulary}. If the vocabulary already contains a word with this name, the existing word is returned.
\wordtable{
\vocabulary{words}
\ordinaryword{create-in}{create-in ( name -- word )}

}
Creates a new word \texttt{name} in the current vocabulary. This word is intended to be called from parsing words (\ref{parsing-words}), and in fact is defined as follows:
\begin{verbatim}
: create-in ( name -- word ) "in" get create ;
\end{verbatim}

\subsection{Word definition}

There are two ways to create a word definition:
\begin{itemize}
\item Using parsing words at parse time,
\item Using defining words at run-time. This is a more dynamic feature that can be used to implement code generation and such, and in fact parse-time defining words are implemented in terms of run-time defining words.
\end{itemize}

\subsubsection{\label{colondefs}Compound definitions}

\newcommand{\colonglos}{\glossary{
name=compound definition,
description=a word defined to execute a quotation consisting of existing words}
\glossary{
name=colon definition,
description=see compound definition}}
\colonglos
A compound definition associates a word name with a quotation that is called when the word is executed.
\wordtable{
\vocabulary{syntax}
\parsingword{:}{:~\emph{name} \emph{definition} ;}
}
A word \texttt{name} is created in the current vocabulary, and is associated with \texttt{definition}.
\begin{verbatim}
: ask-name ( -- name )
    "What is your name? " write read-line ;
: greet ( name -- )
    "Greetings, " write print ;
: friend ( -- )
    ask-name greet ;
\end{verbatim}
By convention, the word name should be followed by a stack effect comment, and for more complex definitions, a documentation comment; see \ref{comments}.
\wordtable{
\vocabulary{words}
\ordinaryword{define-compound}{define-compound ( word quotation -- )}

}
Defines \texttt{word} to call the \texttt{quotation} when executed.
\wordtable{
\vocabulary{words}
\ordinaryword{compound?}{compound?~( object -- ?~)}

}
Tests if the \texttt{object} is a compound word definition.
\wordtable{
\vocabulary{words}
\classword{compound}
}
The class that all compound words are an instance of.

\subsubsection{\label{symbols}Symbols}

\newcommand{\symbolglos}{\glossary{
name=symbol,
description={a word defined to push itself on the stack when executed, created by the \texttt{SYMBOL:}~parsing word}}}
\symbolglos
\wordtable{
\vocabulary{syntax}
\parsingword{SYMBOL:}{SYMBOL:~\emph{name}}
}
A word \texttt{name} is created in the current vocabulary that pushes itself on the stack when executed. Symbols are used to identify variables (\ref{namespaces}) as well as for storing crufties in their properties (\ref{word-props}).
\wordtable{
\vocabulary{words}
\ordinaryword{define-symbol}{define-symbol ( word -- )}

}
Defines \texttt{word} to push itself on the data stack when executed.
\wordtable{
\vocabulary{words}
\ordinaryword{symbol?}{symbol?~( object -- ?~)}

}
Tests if the \texttt{object} is a symbol.
\wordtable{
\vocabulary{words}
\classword{symbol}
}
The class that all symbols are an instance of.

\subsubsection{\label{primitives}Primitives}
\newcommand{\primglos}{\glossary{
name=primitive,
description=a word implemented as native code in the Factor runtime}}
\symbolglos

Executing a primitive invokes native code in the Factor runtime. Primitives cannot be defined through Factor code. Compiled definitions behave similarly to primitives in that the interpreter jumps to native code upon encountering them.
\wordtable{
\vocabulary{words}
\ordinaryword{primitive?}{primitive?~( object -- ?~)}

}
Tests if the \texttt{object} is a primitive.
\wordtable{
\vocabulary{words}
\classword{primitive}
}
The class that all primitives are an instance of.

\subsubsection{\label{deferred}Deferred words and mutual recursion}

\glossary{
name=deferred word,
description={a word without a definition, created by the \texttt{DEFER:}~parsing word}}
Due to the way the parser works, words cannot be referenced before they are defined; that is, source files must order definitions in a strictly bottom-up fashion. Mutually-recursive pairs of words can be implemented by \emph{deferring} one of the words in the pair so that the second word in the pair can parse, then by replacing the deferred definition with a real one.
A demonstration of the idiom:
\begin{verbatim}
DEFER: foe
: fie ... foe ... ;
: foe ... fie ... ;
\end{verbatim}
\wordtable{
\vocabulary{syntax}
\parsingword{DEFER:}{DEFER:~\emph{name}}
}
Create a word \texttt{name} in the current vocabulary that simply raises an error when executed. Usually, the word will be replaced with a real definition later.
\wordtable{
\vocabulary{words}
\ordinaryword{undefined?}{undefined?~( object -- ?~)}

}
Tests if the \texttt{object} is an undefined (deferred) word.
\wordtable{
\vocabulary{words}
\classword{undefined}
}
The class that all undefined words are an instance of.

\subsubsection{Undefining words}

\wordtable{
\vocabulary{syntax}
\parsingword{FORGET:}{FORGET:~\emph{name}}
}
Removes the word \texttt{name} from its vocabulary. Existing definitions that reference the word will continue to work, but newly-parsed occurrences of the word will not locate the forgotten definition. No exception is thrown if no such word exists.
\wordtable{
\vocabulary{words}
\ordinaryword{forget}{forget ( word -- )}

}
Removes the word from its vocabulary. The parsing word \texttt{FORGET:} is implemented using this word.

\subsection{\label{word-props}Word properties}

\glossary{name=word property,
description={a name/value pair stored in a word's properties}}
\glossary{name=word properties,
description={a hashtable associated with each word storing various sundry properties}}

Each word has an associated hashtable of properties. Conventionally, the property names are strings, but nothing requires that this be so.

A common idiom in the Factor library is to use symbols for their properties. 

\wordtable{
\vocabulary{words}
\ordinaryword{word-prop}{word-prop ( word name -- value )}
\ordinaryword{set-word-prop}{set-word-prop ( value word name -- )}

}
Retrieve and store word properties. Note that the stack effect is designed so that it is most convenient when \texttt{name} is a literal that is pushed on the stack right before executing these words. This is usually the case.

\wordtable{
\vocabulary{words}
\ordinaryword{word-name}{word-prop ( word -- name )}
\ordinaryword{word-vocabulary}{word-vocabulary ( word -- vocabulary )}

}
Retreive the name of a word, and the name of the vocabulary it is stored in. The definitions are trivial:
\begin{verbatim}
: word-name "name" word-prop ;
: word-vocabulary "vocabulary" word-prop ;
\end{verbatim}

\wordtable{
\vocabulary{words}
\ordinaryword{word-sort}{word-sort ( list -- list )}

}
Sort a list of words by name.

\wordtable{
\vocabulary{words}
\ordinaryword{word-props}{word-props ( word -- hashtable )}
\ordinaryword{set-word-props}{set-word-props ( hashtable word -- )}

}
Retreive and store the entire set of word properties.

\subsection{Low-level details}

The actual behavior of a word when executed is determined by the values of two slots:
\begin{itemize}
\item The primitive number
\item The primitive parameter
\end{itemize}
The primitive number is an index into an array of native functions in the Factor runtime.
Some frequently-occurring primitive numbers:
\begin{description}
\item[0] deferred word,
\item[1] compound definition -- executes the quotation stored in the parameter slot,
\item[2] symbol -- pushes the value of the parameter slot,
\item[3 onwards] the actual set of primitives, of which there are around 170.
\end{description}
The words outlined in this section should not be used in ordinary code.
\wordtable{
\vocabulary{words}
\ordinaryword{word-primitive}{word-primitive ( word -- n )}
\ordinaryword{set-word-primitive}{set-word-primitive ( word -- n )}

}
Retreives and stores a word's primitive number.

\wordtable{
\vocabulary{words}
\ordinaryword{word-def}{word-def ( word -- object )}
\ordinaryword{set-word-def}{set-word-def ( object word -- )}

}
Retreives and stores a word's primitive parameter. This parameter is only used if the primitive number is 1 (compound definitions) or 2 (symbols). Note that to define a compound definition or symbol, you must use \texttt{define-compound} or \texttt{define-symbol}, as these words do not update the cross-referencing of word dependencies.

\wordtable{
\vocabulary{words}
\ordinaryword{word-xt}{word-xt ( word -- n )}
\ordinaryword{set-word-xt}{set-word-xt ( n word -- )}

}
Retreives and stores a word's \emph{execution token}.

This is an even lower-level facility for working with the address containing native code to be invoked when the word is executed. The compiler sets the execution token to a location in memory containing generated code.

\wordtable{
\vocabulary{words}
\ordinaryword{update-xt}{update-xt ( word -- )}

}
Updates a word's execution token according to its primitive number. When called with a compiled word, has the effect of decompiling the word. The execution token is automatically updated after a call to \texttt{set-word-primitive}.

\wordtable{
\vocabulary{words}
\ordinaryword{recrossref}{recrossref ( word -- )}

}
Updates the cross-referencing database, which you will probably need to do if you mess around with any of the words in this section -- assuming Factor does not crash first, that is.

\section{Objects}

\glossary{name=object,
description=a datum that can be identified}
\mutableglos

Everything in Factor is an object, where an object is a collection of slots. Each object has a unique identity, and references to objects are passed by value on the stack. It is possible to have two references to the same object, and if the object is mutated through one reference, the changes will be visible through the other reference. Not all objects are mutable; the documentation for each class details if its instances are mutable or not.

\subsection{\label{equality}Identity and equality}

\glossary{name=equal,
description={two objects are equal if they have the same class and if their slots are equal, or alternatively, if both are numbers that denote the same value}}
There are two distinct notions of ``sameness'' when it comes to objects. You can test if two references point to the same object, or you can test if two objects are equal in some sense, usually by having the same type and equal slot values.
\wordtable{
\vocabulary{kernel}
\ordinaryword{eq?}{eq?~( object object -- ?~)}
}
Output \texttt{t} if two references point to the same object, and \texttt{f} otherwise.
\wordtable{
\vocabulary{kernel}
\genericword{=}{= ( object object -- ?~)}
}
Output \texttt{t} if two objects are equal, and \texttt{f} otherwise. The precise meaning of equality depends on the object's class, however usually two objects are equal if their slot values are equal. If two objects are equal, they have the same printed representation, although the converse is not always true. In particular:
\begin{itemize}
\item If no more specific method is defined, \texttt{=} calls \texttt{eq?}.
\item Two numbers are equal if they have the same numerical value.
\item Two sequences are equal if they are both instances of the same class, and if they have the same length, and elements.
\item Two hashtables are equal if they hold the same set of key/value pairs.
\item Two tuples are equal if they are of the same class and their slots are equal.
\item Two words are equal if they are the same object.
\end{itemize}
\wordtable{
\vocabulary{kernel}
\genericword{clone}{clone ( object -- object )}
}
Make a fresh object that is equal to the given object. This is not guaranteed to actually copy the object; it does nothing with immutable objects, and does not copy words either. However, sequences and tuples can be cloned to obtain a new shallow copy of the original.

\subsection{Generic words and methods}

\glossary{name=generic word,
description={a word defined using the \texttt{GENERIC:}~parsing word. The behavior of generic words depends on the class of the object at the top of the stack. A generic word is composed of methods, where each method is specialized on a class}}
\glossary{name=method,
description={gives a generic word behavior when the top of the stack is an instance of a specific class}}
Sometimes  you want a word's behavior to depend on the class of the object at the top of the stack, however implementing the word as a set of nested conditional tests is undesirable since it leads to unnecessary coupling -- adding support for a new class requires modifying the original definition of the word.

A generic word is a word whose behavior depends on the class of the
object at the top of the stack, however this behavior is defined in a
decentralized manner.

\wordtable{
\vocabulary{syntax}
\parsingword{GENERIC:}{GENERIC: \emph{word}}
}
Defines a new generic word. Initially, it contains no methods, and thus will raise an error when called.

\wordtable{
\vocabulary{syntax}
\parsingword{M:}{M: \emph{class} \emph{word} \emph{definition} ;}
}
Defines a method, that is, a behavior for the generic \texttt{word} specialized on instances of \texttt{class}. Each method definition
can potentially occur in a different source file.

\subsubsection{\label{method-order}Method ordering}

If two classes have a non-empty intersection, there is no guarantee that one is a subclass of the other. This means there is no canonical linear ordering of classes. The methods of a generic word are linearly ordered, though, and you can inspect this order using the \texttt{order} word.

Suppose you have the following definitions:
\begin{verbatim}
GENERIC: foo
M: integer foo 1 + ;
M: number foo 1 - ;
M: object foo dup 2list ;
\end{verbatim}
Since the \texttt{integer} class is strictly smaller than the \texttt{number} class, which in turn is strictly smaller than the \texttt{object} class, the ordering of methods is not surprising in this case:
\begin{alltt}
\textbf{ok} \bs foo order .
\textbf{[ object number integer ]}
\end{alltt}
However, suppose we had the following set of definitions:
\begin{verbatim}
GENERIC: describe
M: general-t describe drop "a true value" print ;
M: general-list describe drop "a list" print ;
M: object describe drop "an object" print ;
\end{verbatim}
Neither \texttt{general-t} nor \texttt{general-list} contains the other, and their intersection is the non-empty \texttt{cons} class. So the generic word system will place \texttt{object} first in the method order, however either \texttt{general-t} or \texttt{general-list} may come next, and it is pretty much a random choice that depends on hashing:
\begin{alltt}
\textbf{ok} \bs bar order .
\textbf{[ object general-list general-t ]}
\end{alltt}

Therefore, the outcome of calling \texttt{bar} with a cons cell is undefined.

\subsection{Classes}
\glossary{name=class,
description=a set of objects defined in a formal manner. Methods specialize generic words on classes}
\glossary{name=metaclass,
description={a set of classes sharing common traits. Examples include \texttt{builtin}, \texttt{union}, and \texttt{tuple}}}

\wordtable{
\vocabulary{generic}
\classword{object}
}
Every object is a member of the \texttt{object} class. If you provide a method specializing
on the \texttt{object} class for some generic word, the method will be
invoked when no more specific method exists. For example:
\begin{verbatim}
GENERIC: describe
M: number describe
    "The number " write . ;
M: object describe
    "I don't know anything about " write . ;
\end{verbatim}
Each class has a membership predicate named
after the class with a \texttt{?}~suffix, with the following exceptions:
\begin{description}
\item[object] there is no need for a predicate word, since
every object is an instance of this class.
\item[f] the only instance of this class is the singleton
\texttt{f} signifying falsity, missing value, and empty list, and the predicate testing for this is the built-in library word \texttt{not}.
\item[t] the only instance of this class is the canonical truth value
\texttt{t}. You can write \texttt{t =} to test for this object, however usually
any object distinct from \texttt{f} is taken as a truth value, and \texttt{t} is not tested for directly.
\end{description}

\subsubsection{Built-in classes}
\glossary{name=type,
description={an object invariant that describes its shape. An object's type is constant for the lifetime of the object, and there is only a fixed number of types built-in to the run-time. See class}}
\glossary{name=built-in class,
description=see type}
Every object is an instance of to exactly one type, and the type is constant for the lifetime of the object. There is only a fixed number of types built-in to the run-time, and corresponding to each type is a \emph{built-in class}:
\begin{verbatim}
alien
array
bignum
byte-array
complex
cons
dll
f
fixnum
float
ratio
sbuf
string
t
tuple
vector
word
\end{verbatim}
\wordtable{
\vocabulary{kernel}
\ordinaryword{type}{type ( object -- n )}
}
Outputs the type number of a given object. Most often, the \texttt{class} word is more useful.
\wordtable{
\vocabulary{kernel}
\ordinaryword{class}{class ( object -- class )}
}
Outputs the canonical class of a given object. While an object may be an instance of more than one class, the canonical class is either the built-in class, or if the object is a tuple, the tuple class. Examples:
\begin{alltt}
\textbf{ok} 1.0 class .
\textbf{float}
\textbf{ok} TUPLE: point x y z ;
\textbf{ok} << point f 1 2 3 >> class .
\textbf{point}
\end{alltt}

\subsubsection{Unions}
\glossary{name=union,
description={a class whose set of instances is the union of the set of instances of a list of member classes}}
An object is an instance of a union class if it is an instance of one of its members. Union classes are used to associate the same method with several different classes, as well as to conveniently define predicates.
\wordtable{
\vocabulary{syntax}
\parsingword{UNION:}{UNION: \emph{name} \emph{members} ;}
}
Defines a union class. For example, the Factor library defines some unions over numeric types:
\begin{verbatim}
UNION: integer fixnum bignum ;
UNION: rational integer ratio ;
UNION: real rational float ;
UNION: number real complex ;
\end{verbatim}
Now, the absolute value function can be defined in an efficient manner
for real numbers, and in a more general fashion for complex numbers:
\begin{verbatim}
GENERIC: abs ( z -- |z| )
M: real abs dup 0 < [ neg ] when ;
M: complex abs >rect mag2 ;
\end{verbatim}

\subsubsection{Complements}
\glossary{name=complement,
description={a class whose set of instances is the set of objects that are not instances of a specific class}}

An object is an instance of a complement if it is not an instance of the complement's parameter.
\wordtable{
\vocabulary{syntax}
\parsingword{COMPLEMENT:}{COMPLEMENT: \emph{name} \emph{parameter}}
}
Defines a complement class. For example, the class of all values denoting ``true'' is defined as follows:
\begin{verbatim}
COMPLEMENT: general-t f
\end{verbatim}

\subsubsection{Predicates}
\glossary{name=predicate,
description={a word with stack effect \texttt{( object -- ?~)}, or more alternatively, a class whose instances are the instances of a superclass that satisfy an arbitrary predicate}}
An object is an instance of a predicate classes if it is an instance of the predicate's parent class, and if it satisfies the predicate definition.

Each predicate must be
defined as a subclass of some other class. This ensures that predicates inheriting from disjoint classes do not need to be
exhaustively tested during method dispatch.
\wordtable{
\vocabulary{syntax}
\parsingword{PREDICATE:}{PREDICATE: \emph{parent} \emph{name} \emph{predicate} ;}
}
Defines a predicate class deriving from \texttt{parent} whose instances are the instances of \texttt{superclass} that satisfy the \texttt{predicate} quotation. The predicate quotation must have stack effect \texttt{( object -- ?~)}.

For example, the \texttt{strings} vocabulary contains subclasses of \texttt{integer}
classifying various ASCII characters:
\begin{verbatim}
PREDICATE: integer blank " \t\n\r" string-contains? ;
PREDICATE: integer letter CHAR: a CHAR: z between? ;
PREDICATE: integer LETTER CHAR: A CHAR: Z between? ;
PREDICATE: integer digit CHAR: 0 CHAR: 9 between? ;
PREDICATE: integer printable CHAR: \s CHAR: ~ between? ;
\end{verbatim}

\subsubsection{Operations on classes}
\wordtable{
\vocabulary{kernel}
\ordinaryword{class-and}{class-and ( class class -- class )}
\ordinaryword{class-or}{class-or ( class class -- class )}

}
Intersection and union of classes. Note that the returned class might not be the exact desired class; for example, \texttt{object} is output if no suitable class definition could be found at all.
\wordtable{
\vocabulary{kernel}
\ordinaryword{class<}{class< ( class class -- class )}
}
Classes are partially ordered. This ordering determines the method ordering of a generic word (\ref{method-order}).

\subsection{\label{tuples}Tuples}
\tupleglos

Tuples are user-defined classes composed of named slots. All tuples have the same type, however distinct classes of tuples are defined.
\wordtable{
\vocabulary{syntax}
\parsingword{TUPLE:}{TUPLE: \emph{name} \emph{slots} ;}
}
Defines a new tuple class with membership predicate \texttt{name?}~and constructor \texttt{<name>}.

The constructor takes slots in left-to-right order from the stack. After construction, slots are read and written using various automatically-defined words with names of the
form \texttt{\emph{class}-\emph{slot}} and \texttt{set-\emph{class}-\emph{slot}}.

Here is an example:
\begin{verbatim}
TUPLE: point x y z ;
\end{verbatim}
This defines a new class named \texttt{point}, along with the
following set of words:
\begin{verbatim}
<point> point?
point-x set-point-x
point-y set-point-y
point-z set-point-z
\end{verbatim}
The word \texttt{<point>} takes the slot values from the stack and
produces a new \texttt{point}:
\begin{alltt}
\textbf{ok} 1 2 3 <point> .
\textbf{<< point 1 2 3 >>}
\end{alltt}

\subsubsection{Constructors}

Constructors are named after the tuple class surrounded in angle
brackets (\texttt{<}~and~\texttt{>}). A default constructor is provided
that reads slot values from the stack, however a custom constructor can
be defined using the \texttt{C:} parsing word.
\wordtable{
\vocabulary{syntax}
\parsingword{C:}{C: \emph{class} \emph{definition} ;}
}
Define a \texttt{<class>} word that creates a tuple instance of the \texttt{class}, then applies the \texttt{definition} to this new tuple. The \texttt{definition} quotation must have stack effect \texttt{( tuple -- tuple )}.

\subsubsection{Delegation}

\glossary{name=delegate,
description={a fa\,cade object's delegate receives unhandled methods that are called on the fa\,cade}}
\glossary{name={fa\,cade},
description=an object with a delegate}

Each tuple can have an optional delegate tuple. Generic words called on
the tuple that do not have a method for the tuple's class will be passed on
to the delegate. Note that delegation to objects that are not tuples is not fully supported at this stage and might not work as you might expect.
\wordtable{
\vocabulary{syntax}
\ordinaryword{delegate}{delegate ( object -- object )}

}
Returns an object's delegate, or \texttt{f} if no delegate is set. Note that in this case,  undefined methods will be passed to \texttt{f}; rather an error is raised immediately.
\wordtable{
\vocabulary{syntax}
\ordinaryword{set-delegate}{set-delegate ( object tuple -- )}

}
Sets a tuple's delegate.

Factor uses delegation is used instead of inheritance, but it is not a direct
substitute; in particular, the semantics differ in that a delegated
method call receives the delegate on the stack, not the original object.

\chapter{Library reference}

\section{Sequences}

\glossary{name=sequence,
description=an object storing a linearly-ordered set of elements}
A sequence is a linearly-ordered collection of objects. A set of built-in sequence types  is provided by the library.

\begin{tabular}[t]{l|c|c|c|c|c|l}
\multicolumn{4}{l|}{}&\multicolumn{2}{c|}{Adding elements}&\multicolumn{1}{l}{}\\
\hline
Class&Mutable&Growable&Lookup&at start&at end&Primary purpose\\
\hline
%\texttt{array}&$\surd$&&$O(1)$&&&Low-level and unsafe\\
\texttt{list}&&&$O(n)$&$O(1)$&$O(n)$&Functional manipulation\\
\texttt{vector}&$\surd$&$\surd$&$O(1)$&$O(n)$&$O(1)$&Imperitive aggregation\\
\texttt{sbuf}&$\surd$&$\surd$&$O(1)$&$O(n)$&$O(1)$&Character accumilation\\
\texttt{string}&&&$O(1)$&&&Immutable text strings
\end{tabular}

Additionally, user-defined classes can implement the sequence protocol and gain the ability to reuse many of the words in this section.

\subsection{Sequence protocol}

The following set of generic words is the core of the sequence protocol. The mutating words are not supported by all sequences; in particular, lists and strings are immutable.

\glossary{name=resizable sequence,
description={a sequence implementing the \texttt{set-length} generic word. For example, vectors and string buffers}}
\glossary{name=mutable sequence,
description={a sequence implementing the \texttt{set-nth} generic word. For example, vectors and string buffers}}
The sequence protocol consists of a set of generic words. Any object that is an instance of a class implementing these generic words can be thought of as a sequence, and given to the words in the following sections.

\wordtable{
\vocabulary{sequences}
\genericword{length}{length ( seq -- n )}
}
Outputs the length of the sequence. All sequences support this operation.
\wordtable{
\vocabulary{sequences}
\genericword{set-length}{set-length ( n seq -- )}
}
Resizes the sequence. Only vectors and string buffers support this operation.

\wordtable{
\vocabulary{sequences}
\genericword{nth}{nth ( n seq -- elt )}
}
Outputs the $n$th element of the sequence. Elements are numbered starting from 0, so the last element has an index one less than the length of the sequence. An exception should be thrown if an out-of-bounds index is accessed. All sequences support this operation, however with lists it has non-constant running time.

\wordtable{
\vocabulary{sequences}
\genericword{set-nth}{set-nth ( elt n seq -- )}
}
Sets the $n$th element of the sequence. Storing beyond the end of a resizable sequence such as a vector or string buffer grows the sequence. Storing to a negative index is always an error.

\subsection{Sequence operations}

\subsubsection{Queries}

The following set of operations inspect sequence elements without modifying or creating anything.

\wordtable{
\vocabulary{sequences}
\genericword{empty?}{empty?~( seq -- ?~)}
}
Tests if the sequence contains any elements. The default implementation of this word tests if the length is zero; user-defined sequences can provide a custom implementation that is more efficient.
\wordtable{
\vocabulary{sequences}
\ordinaryword{index}{index ( obj seq -- n )}
}
Outputs the index of the first element in the sequence equal to \texttt{obj}. If no element is found, outputs $-1$.
\wordtable{
\vocabulary{sequences}
\ordinaryword{index*}{index* ( obj i seq -- n )}
}
Outputs the index of the first element in the sequence equal to \texttt{obj}, starting from \texttt{i}. If no element is found, outputs $-1$.
\wordtable{
\vocabulary{sequences}
\ordinaryword{peek}{peek ( sequence -- element )}
}
Outputs the last element of the sequence. Throws an exception if the sequence is empty.
\wordtable{
\vocabulary{sequences}
\ordinaryword{sequence=}{sequence= ( s1 s2 -- ?~)}

}
Tests if the two sequences have the same length and elements. This is weaker than \texttt{=}, since it does not ensure that the sequences are instances of the same class.

\subsubsection{Functional operations}

The following set of sequence operations do not modify their inputs.

\wordtable{
\vocabulary{sequences}
\ordinaryword{append}{append ( s1 s2 -- seq )}
}
Output a new sequence consisting of the elements of \texttt{s1} followed by the elements of \texttt{s2}. The new sequence is of the same class as \texttt{s1}.
\wordtable{
\vocabulary{sequences}
\ordinaryword{append3}{append3 ( s1 s2 s3 -- seq )}
}
Append the three sequences \texttt{s1}, \texttt{s2} and \texttt{s3} into a new sequence of the same class as \texttt{s1}.
\wordtable{
\vocabulary{sequences}
\ordinaryword{concat}{concat ( sequence -- sequence )}
}
The input is a sequence of sequences. If the input is empty, the output is the empty list (\texttt{f}). Otherwise, the elements of the input sequence are concatenated together, and a new sequence of the same type as the first element is output.
\begin{alltt}
\textbf{ok} [ "a" [ CHAR: b ] \tto CHAR: c \ttc ] concat .
\textbf{"abc"}
\end{alltt}
\wordtable{
\vocabulary{sequences}
\genericword{reverse}{reverse ( seq -- seq )}
}
Outputs a new sequence of the same class, with the reverse element order.

\subsubsection{Imperitive operations}

The following set of sequence operations modify their inputs. The ``n'' prefix denotes ``non-constructive''; these words do not construct new output objects. None of these operations are permitted on immutable sequences like lists and strings.

\wordtable{
\vocabulary{sequences}
\ordinaryword{nappend}{nappend ( s1 s2 -- )}
}
Append \texttt{s2} to \texttt{s1}. Nothing is output, and \texttt{s1} is modified.
\wordtable{
\vocabulary{sequences}
\ordinaryword{nreverse}{nreverse ( sequence -- )}
}
Reverses the elements of \texttt{seq}. Nothing is output, and \texttt{seq} is modified.
\wordtable{
\vocabulary{sequences}
\ordinaryword{push}{push ( element sequence -- )}
\ordinaryword{pop}{pop ( sequence -- element )}
}

Adds and removes an element at the end of the sequence. The sequence's length is adjusted accordingly. These are implemented as follows:
\begin{verbatim}
: push ( element sequence -- )
    dup length swap set-nth ;
: pop ( sequence -- element )
    dup peek >r dup length 1 - swap set-length r> ;
\end{verbatim}

\subsection{Sequence combinators}

\wordtable{
\vocabulary{sequences}
\ordinaryword{change-nth}{change-nth ( seq n quot -- )}
\texttt{quot:~element -- element}\\
}
Applies the quotation to the $n$th element of the sequence, and store the output back in the $n$th slot of the sequence. This modifies \texttt{seq} and so throws an exception if it is immutable.
\wordtable{
\vocabulary{sequences}
\ordinaryword{seq-each}{seq-each ( seq quot -- )}
\texttt{quot:~element --}\\
}
Applies the quotation to each element of the sequence.
\wordtable{
\vocabulary{sequences}
\ordinaryword{tree-each}{tree-each ( seq quot -- )}
\texttt{quot:~element --}\\
}
Applies the quotation to each element of the sequence. Elements that are themselves sequences are iterated recursively.
\wordtable{
\vocabulary{sequences}
\ordinaryword{seq-map}{seq-map ( seq quot -- seq )}
\texttt{quot:~element -- element}\\
}
Applies the quotation to each element yielding a new element. The new elements are collected into a sequence of the same class as the input sequence.
\wordtable{
\vocabulary{sequences}
\ordinaryword{nmap}{nmap ( seq quot -- )}
\texttt{quot:~element -- element}\\
}
Applies the quotation to each element yielding a new element, storing the new elements back in the original sequence. This modifies \texttt{seq} and so throws an exception if it is immutable.
\wordtable{
\vocabulary{sequences}
\ordinaryword{seq-2map}{seq-2map ( s1 s2 quot -- seq )}
\texttt{quot:~e1 e2 -- element}\\
}
Applies the quotation to pairs of elements from \texttt{s1} and \texttt{s2}, yielding a new element. The new elements are collected into a sequence of the same class as \texttt{s1}. Here is an example computing the pair-wise product of the elements of two vectors:
\begin{alltt}
\textbf{ok} \tto 5 3 -2 \ttc \tto 8 16 3 \ttc [ * ] seq-2map .
\textbf{\tto 40 48 -6 \ttc}
\end{alltt}
\wordtable{
\vocabulary{sequences}
\ordinaryword{2nmap}{2nmap ( s1 s2 quot -- )}
\texttt{quot:~e1 e2 -- element}\\
}
Applies the quotation to pairs of elements from \texttt{s1} and \texttt{s2}, yielding a new element. The new element is stored back in \texttt{s1}. This modifies \texttt{s1} and so throws an exception if it is immutable.
\wordtable{
\vocabulary{sequences}
\ordinaryword{seq-each-with}{seq-each-with ( object seq quot -- )}
\texttt{quot:~object element --}\\
\ordinaryword{tree-each-with}{tree-each-with ( obj seq quot -- )}
\texttt{quot:~obj element --}\\
}
Curried forms of the above combinators. They pass an additional object to each invocation of the quotation.

\subsection{\label{vectors}Vectors}

\wordtable{
\vocabulary{vectors}
\classword{vector}
}
\vectorglos
A vector is a growable, mutable sequence whose elements are stored in a contiguous range of memory. The literal syntax is covered in \ref{vector-literals}. Very few words operate specifically on vectors; most operations on vectors are done with generic sequence words.

\wordtable{
\vocabulary{vectors}
\ordinaryword{vector?}{vector?~( object -- ?~)}

}
Tests if the object at the top of the stack is a vector.
\wordtable{
\vocabulary{vectors}
\ordinaryword{>vector}{>vector~( sequence -- vector )}
}
Turns any type of sequence into a vector. Given a vector, this makes a fresh copy.
\wordtable{
\vocabulary{vectors}
\ordinaryword{<vector>}{<vector>~( capacity -- vector )}
}
Creates a new vector with an initial capacity that determines how many elements it can store before it needs resizing. The initial length is zero.
\wordtable{
\vocabulary{vectors}
\ordinaryword{empty-vector}{empty-vector~( length -- vector )}
}
Creates a new vector of the requested length, where all elements are initially \texttt{f}.
\wordtable{
\vocabulary{vectors}
\ordinaryword{zero-vector}{zero-vector~( length -- vector )}
}
Creates a new vector of the requested length, where all elements are initially \texttt{f}.
\wordtable{
\vocabulary{vectors}
\ordinaryword{vector-project}{vector-project~( n quot -- vector )}
\texttt{quot:~i -- element}\\
}
Calls the quotation sequentially with integers $0$ up to $n-1$, collecting the results into a new vector.

\subsection{Cons cells}

\consglos
\glossary{name=car,description=the first component of a cons cell}
\glossary{name=cdr,description=the second component of a cons cell}

\wordtable{
\vocabulary{lists}
\classword{cons}
}
A \emph{cons cell} is an ordered pair of values. The first value is called the \emph{car},
the second is called the \emph{cdr}. The literal syntax of cons cells is documented in \ref{listsyntax}.

\wordtable{
\vocabulary{lists}
\ordinaryword{cons?}{cons?~( object -- ?~)}
}
Tests if the object at the top of the stack is a cons cell.
\wordtable{
\vocabulary{lists}
\ordinaryword{cons}{cons ( car cdr -- cons )}
\ordinaryword{swons}{swons ( cdr car -- cons )}
}
Creates a new cons cell from two components. The \texttt{swons} word is defined as follows:
\begin{verbatim}
: swons swap cons ;
\end{verbatim}
\wordtable{
\vocabulary{lists}
\ordinaryword{car}{car ( cons -- car )}
\ordinaryword{cdr}{cdr ( cons -- cdr )}
}
Outputs the individual components of a cons cell. Taking the car of cdr of the empty list yields the empty list back.
\begin{alltt}
\textbf{ok} 5 "blind mice" cons car .
\textbf{5}
\textbf{ok} "peanut butter" "jelly" cons cdr .
\textbf{"jelly"}
\end{alltt}
\wordtable{
\vocabulary{lists}
\ordinaryword{uncons}{uncons ( cons -- car cdr )}
\ordinaryword{unswons}{unswons ( cons -- cdr car )}
}
Pushes both the car and cdr of the cons cell at once. These words are implemented in the obvious way:
\begin{verbatim}
: uncons ( cons -- car cdr ) dup car swap cdr ;
: unswons ( cons -- car cdr ) dup cdr swap car ;
\end{verbatim}
Here is an example:
\begin{alltt}
\textbf{ok} {[[} "potatoes" "gravy" {]]} uncons .s
\textbf{"gravy"
"potatoes"}
\end{alltt}
Cons cells, and by extension lists, are immutable.

\subsubsection{\label{lists}Lists}

\listglos
\glossary{name=improper list,description={a sequence of cons cells where the cdr of the last cons cell is not \texttt{f}}}
\glossary{name=general list,description={a proper or improper list; that is, either \texttt{f} or a cons cell}}

Lists of values are represented with nested cons cells. The car is the first element of the list; the cdr is the rest of the list. The value \texttt{f} represents the empty list.

The following example demonstrates the construction of lists as chains of cons cells, along with the literal syntax used to print lists:
\begin{alltt}
\textbf{ok} {[} 1 2 3 {]} car .
\textbf{1}
\textbf{ok} {[} 1 2 3 {]} cdr .
\textbf{{[} 2 3 {]}}
\textbf{ok} {[} 1 2 3 {]} cdr cdr .
\textbf{{[} 3 {]}}
\end{alltt}

\begin{figure}
\caption{Cons cells making up the list \texttt{[ 1 2 3 ]}}
\begin{center}
\scalebox{0.5}{\epsfig{file=cons.eps}}
\end{center}
\end{figure}

List operations are typically implemented in a recursive fashion, where the cdr of the list is taken until the desired element is reached.

\wordtable{
\vocabulary{lists}
\classword{general-list}
\classword{list}
}
A \emph{general list} is either the empty list or a cons cell. A \emph{list} is either the empty list or a cons cell whose cdr is also a list. A list is sometimes also known as a \emph{proper list}, and a general list that is not a proper list is known as a \emph{improper list}.

Not all list operations will function given an improper list,
however methods are usually defined on \texttt{general-list} not \texttt{list} since dispatching on \texttt{list} involves a costly check.

\subsubsection{List operations}

\wordtable{
\vocabulary{lists}
\ordinaryword{>list}{>list ( sequence -- list )}
}
Converts an arbitrary sequence into a list.
\wordtable{
\vocabulary{lists}
\ordinaryword{list?}{list?~( obj -- ?~)}
}
Tests if the object at the top of the stack is a proper list.
\wordtable{
\vocabulary{lists}
\ordinaryword{unit}{unit ( obj -- [ obj ] )}
}
Makes a list of one element.
\wordtable{
\vocabulary{lists}
\ordinaryword{2list}{2list ( o1 o2 -- [ o1 o2 ] )}
}
Makes a list of two elements.
\wordtable{
\vocabulary{lists}
\ordinaryword{2unlist}{2unlist ( [ o1 o2 ] -- o1 o2 )}
}
Pushes the first two elements of a list.
\wordtable{
\vocabulary{lists}
\ordinaryword{3list}{3list ( o1 o2 o3 -- [ o1 o2 o3 ] )}
}
Makes a list of three elements.
\wordtable{
\vocabulary{lists}
\ordinaryword{3unlist}{3unlist ( [ o1 o2 o3 ] -- o1 o2 o3 )}
}
Pushes the first three elements of a list.
\wordtable{
\vocabulary{lists}
\ordinaryword{unique}{unique ( obj list -- list )}
}
If the list already contains an element equal to the object, do nothing, otherwise cons the object into the list.
\wordtable{
\vocabulary{lists}
\ordinaryword{prune}{prune ( list -- list )}
}
Removes all duplicates from the list by testing elements for equality.
\wordtable{
\vocabulary{lists}
\ordinaryword{all=?}{all=?~( list -- ?~)}
}
Tests if all elements of the list are equal. For the empty list, this is vacuously true.
\wordtable{
\vocabulary{lists}
\ordinaryword{head}{head~( list n -- list )}
}
Outputs a new list consisting of the first \texttt{n} elements of \texttt{list}. This allocates memory.
\wordtable{
\vocabulary{lists}
\ordinaryword{tail}{tail~( list n -- list )}
}
Outputs a new list consisting of the elements of \texttt{list} from the $n$th index onward. This does not allocate memory; rather it simply takes the \texttt{cdr} \texttt{n} times.
\wordtable{
\vocabulary{lists}
\ordinaryword{count}{count~( n -- list )}
}
Return a new list containing all integers from 0 up to $n-1$, inclusive.

\subsubsection{Set-theoretic operations}

\wordtable{
\vocabulary{lists}
\ordinaryword{contains?}{contains?~( object list -- ?~)}
}
Tests if \texttt{list} contains an element equal to \texttt{object}.
\wordtable{
\vocabulary{lists}
\ordinaryword{memq?}{memq?~( object list -- ?~)}
}
Tests if \texttt{list} contains \texttt{object}. Elements are compared by identity.
\wordtable{
\vocabulary{lists}
\ordinaryword{contained?}{contained?~( l1 l2 -- ?~)}
}
Tests if every element of \texttt{l1} is equal to some element of \texttt{l2}.
\wordtable{
\vocabulary{lists}
\ordinaryword{remove}{remove ( object list -- list )}
}
Outputs a new list containing all elements of the \texttt{list} except those equal to the \texttt{object}.
\wordtable{
\vocabulary{lists}
\ordinaryword{remq}{remq ( object list -- list )}
}
Outputs a new list containing all elements of the \texttt{list} except \texttt{object}. Elements are compared by identity.
\wordtable{
\vocabulary{lists}
\ordinaryword{intersection}{intersection ( list list -- list )}
}
Outputs a list of elements present in both lists.
\wordtable{
\vocabulary{lists}
\ordinaryword{intersection}{difference ( l1 l2 -- list )}
}
Outputs a list of elements present in \texttt{l2} but not \texttt{l1}.

\subsubsection{List combinators}

\wordtable{
\vocabulary{lists}
\ordinaryword{each}{each ( list quot -- )}
\texttt{quot:~element --}\\
}
Applies the quotation to each element of the list.
\wordtable{
\vocabulary{lists}
\ordinaryword{map}{map ( list quot -- list )}
\texttt{quot:~element -- element}\\
}
Applies the quotation to each element yielding a new element. The new elements are collected into a new list.
\wordtable{
\vocabulary{lists}
\ordinaryword{subset}{subset ( list quot -- list )}
\texttt{quot:~element -- ?}\\
}
Applies the quotation to each element, and outputs a new list containing the elements of the original list for which the quotation output true.
\wordtable{
\vocabulary{lists}
\ordinaryword{some?}{some?~( list quot -- list )}
\texttt{quot:~element -- ?}\\
}
Applies the quotation to each element, and outputs the rest of the list upon encountering an element for which the quotation outputs true. If the quotation did not output true for any element, \texttt{some?}~outputs \texttt{f}. Note that the output is a generalized boolean; if the quotation matched any element, the result is true.
\wordtable{
\vocabulary{lists}
\ordinaryword{all?}{all?~( list quot -- list )}
\texttt{quot:~element -- ?}\\
}
Outputs \texttt{t} if the quotation yields true when applied to each element, otherwise outputs \texttt{f}. Given the empty list, vacuously outputs \texttt{t}.
\wordtable{
\vocabulary{lists}
\ordinaryword{sort}{all?~( list quot -- list )}
\texttt{quot:~e1 e2 -- ?}\\
}
Sorts the list by comparing each pair of elements with the quotation. The quotation should output \texttt{t} if \texttt{e2} is to come before \texttt{e1} in the list. For example, to sort a list of numbers in ascending order, you can do the following:
\begin{alltt}
\textbf{ok} [ 8 6 9 1 10 3 ] [ > ] sort .
[ 1 3 6 8 9 10 ]
\end{alltt}
\wordtable{
\vocabulary{lists}
\ordinaryword{each-with}{each-with ( object list quot -- )}
\texttt{quot:~object element --}\\
\ordinaryword{map-with}{map-with ( object list quot -- list )}
\texttt{quot:~object element -- element}\\
\ordinaryword{subset-with}{subset-with ( object list quot -- list )}
\texttt{quot:~object element -- ?}\\
\ordinaryword{some-with?}{some-with?~( object list quot -- ?~)}
\texttt{quot:~object element -- ?}\\
\ordinaryword{all-with?}{all-with?~( object list quot -- ?~)}
\texttt{quot:~object element -- ?}\\
}
Curried forms of the above combinators. They pass an additional object to each invocation of the quotation.

\subsubsection{Queues}

The following set of words manages LIFO (last-in-first-out) queues. Queues are built up from cons cells, and hence are immutable; queue operations always return a new queue.

\wordtable{
\vocabulary{lists}
\ordinaryword{<queue>}{<queue> ( -- queue )}
}
Makes a new queue with no elements.
\wordtable{
\vocabulary{lists}
\ordinaryword{queue-empty?}{queue-empty? ( queue -- ?~)}
}
Outputs \texttt{t} if the given queue does not contain any elements, \texttt{f} otherwise.
\wordtable{
\vocabulary{lists}
\ordinaryword{deque}{deque ( queue -- element queue )}
}
Dequeues an element and outputs a new queue without that element.
\wordtable{
\vocabulary{lists}
\ordinaryword{enque}{deque ( element queue -- queue )}
}
Enqueues an element and outputs a new queue.

\subsection{\label{strings}Strings}

\stringglos
\wordtable{
\vocabulary{strings}
\classword{string}
}
A string is an immutable sequence of characters. The literal syntax is covered in \ref{string-literals}. Characters do not have a distinct data type, so elements taken out of strings appear as integers on the stack.

\wordtable{
\vocabulary{strings}
\ordinaryword{string?}{string?~( obj -- ?~)}

}
Tests if the object at the top of the stack is a string.
\wordtable{
\vocabulary{strings}
\ordinaryword{>string}{>string~( sequence -- string )}
}
Turns any type of sequence with all-integer elements into a string. The integer elements are interpreted as characters.
\wordtable{
\vocabulary{strings}
\ordinaryword{string-compare}{string-compare~( s1 s2 -- n )}

}
Compares two strings lexicographically (dictionary order). The output value is one of the following:
\begin{description}
\item[Positive] indicating that \texttt{s1} follows \texttt{s2}
\item[Zero] indicating that \texttt{s1} is equal to \texttt{s2}
\item[Negative] indicating that \texttt{s1} precedes \texttt{s2}
\end{description}
\wordtable{
\vocabulary{strings}
\ordinaryword{string>}{string> ( s1 s2 -- ?~)}

}
Tests if \texttt{s1} follows \texttt{s2}. Implemented as follows:
\begin{verbatim}
: string> ( s1 s1 -- ? ) string-compare 0 > ;
\end{verbatim}
This is used to sort lists of strings:
\begin{alltt}
\textbf{ok} [ "Curry" "Apple" "Veal" "Turkey" ] [ string> ] sort .
[ "Apple" "Curry" "Turkey" "Veal" ]
\end{alltt}
\wordtable{
\vocabulary{strings}
\ordinaryword{fill}{fill~( n char -- string )}

}
Creates a string with \texttt{char} repeated $n$ times.
\wordtable{
\vocabulary{strings}
\ordinaryword{pad}{pad~( string n char -- string )}

}
Creates a string with \texttt{char} repeated $l-n$ times, where $l$ is the length of \texttt{string}. If $l>n$, the empty string is output.

\subsubsection{Substring testing}

\wordtable{
\vocabulary{strings}
\ordinaryword{string-contains?}{string-contains?~( s1 s2 -- ?~)}
}
Tests if \texttt{s2} contains \texttt{s1} as a substring.
\wordtable{
\vocabulary{strings}
\ordinaryword{string-head?}{string-head?~( s1 s2 -- ?~)}
\ordinaryword{string-tail?}{string-tail?~( s1 s2 -- ?~)}

}
Tests if \texttt{s1} starts or ends with \texttt{s1} as a substring. If \texttt{s1} is longer than \texttt{s2}, outputs \texttt{f}.

\subsubsection{Slicing and splitting}

\wordtable{
\vocabulary{strings}
\ordinaryword{string/}{string/ ( string n -- s1 s2 )}
}
Outputs a pair of strings that equal the original string when concatenated. The first string has length $n$, the second has length $l-n$ where $l$ is the length of the input.
\begin{alltt}
\textbf{ok} "Hello world" 5 string/ .s
\textbf{" world"
"Hello"}
\end{alltt}
\wordtable{
\vocabulary{strings}
\ordinaryword{string//}{string// ( string n -- s1 s2 )}
}

Outputs a pair of strings that equal the original string, excluding the $n$th element, when concatenated. The first string has length $n$, the second has length $l-n$ where $l$ is the length of the input.
\begin{alltt}
\textbf{ok} "Hello world" 5 string// .s
\textbf{"world"
"Hello"}
\end{alltt}
\wordtable{
\vocabulary{strings}
\ordinaryword{?string-head}{?string-head~( s1 s2 -- string ?~)}
\ordinaryword{?string-tail}{?string-tail~( s1 s2 -- string ?~)}
}
Tests if \texttt{s1} starts or ends with \texttt{s1} as a substring. If there is a match, outputs the subrange of \texttt{s1} excluding \texttt{s1} followed by \texttt{t}. If there is no match, outputs \texttt{s1} followed by \texttt{f}.
\wordtable{
\vocabulary{strings}
\ordinaryword{split1}{split1~( str split -- before after )}

}
If \texttt{string} does not contain \texttt{split} as a substring, then \texttt{before} is equal to the \texttt{string}, and \texttt{after} is \texttt{f}. Otherwise, \texttt{before} and \texttt{after} are both strings, and yield the input excluding \texttt{split} when concatenated.
\wordtable{
\vocabulary{strings}
\ordinaryword{split}{split~( str split -- list )}
}
Outputs a list of substrings taken between occurrences of \texttt{split} in \texttt{string}. If \texttt{split} does not occur inside \texttt{string}, outputs a singleton list containing \texttt{string} only.
\begin{alltt}
\textbf{ok} "/usr/local/bin" CHAR: / split .
\textbf{[ "" "usr" "local" "bin" ]}
\end{alltt}
\wordtable{
\vocabulary{strings}
\ordinaryword{split-n}{split-n~( str n -- list )}
}
Splits the string into groups of \texttt{n} characters and collects them in a list. If the string's length is not a multiple of \texttt{n}, the final string in the list might be shorter.

\subsubsection{Characters}

\wordtable{
\vocabulary{strings}
\ordinaryword{ch>string}{ch>string ( n -- string )}
}
Converts an integer representing a character value into a single-element string.
\wordtable{
\vocabulary{strings}
\ordinaryword{blank?}{blank?~( n -- ?~)}
\ordinaryword{letter?}{letter?~( n -- ?~)}
\ordinaryword{LETTER?}{LETTER?~( n -- ?~)}
\ordinaryword{digit?}{digit?~( n -- ?~)}
\ordinaryword{printable?}{printable?~( n -- ?~)}
\ordinaryword{quotable?}{quotable?~( n -- ?~)}
\ordinaryword{url-quotable?}{url-quotable?~( n -- ?~)}
}
Various character classification predicates.

\subsection{\label{string-buffers}String buffers}

\sbufglos
\wordtable{
\vocabulary{strings}
\classword{sbuf}
}
A string buffer is a mutable and growable sequence of characters. String buffers can be used to construct new strings by accumilating substrings and characters, however usually they are only used indirectly, since the sequence construction words in \ref{make-seq} are more convenient to use in many cases.
\wordtable{
\vocabulary{strings}
\ordinaryword{sbuf?}{sbuf?~( object -- ?~)}
}
Tests if the object at the top of the stack is a string buffer.
\wordtable{
\vocabulary{strings}
\ordinaryword{>sbuf}{>sbuf~( sequence -- sbuf )}
}
Turns any type of sequence into a string buffer. Given a string buffer, this makes a fresh copy.
\wordtable{
\vocabulary{strings}
\ordinaryword{sbuf>string}{sbuf>string~( sbuf -- string )}
}
Turns a string buffer into a string holding the same characters.

String buffers support the stream output protocol (\ref{stream-protocol}).

\subsection{\label{make-seq}Constructing sequences}

The library supports an idiom where sequences can be constructed without passing the partial sequence being built on the stack. This reduces stack noise, and thus simplifies code and makes it easier to understand.

\newcommand{\dynamicscopeglos}{\glossary{
name=dynamic scope,
description={a variable binding policy where bindings established in a scope are visible to all code executed while the scope is active}}}
\dynamicscopeglos
\wordtable{
\vocabulary{namespaces}
\ordinaryword{make-list}{make-list ( quot -- list )}
\ordinaryword{make-string}{make-string ( quot -- string )}
\ordinaryword{make-sbuf}{make-sbuf ( quot -- string )}
\ordinaryword{make-vector}{make-vector ( quot -- vector )}
}
Calls the quotation in a new \emph{dynamic scope}. The quotation and any words it calls can execute the \texttt{,} and \texttt{\%} words to add elements at the end of the sequence being constructed.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{,}{,~( element -- )}
}
Adds the element to the end of the sequence being constructed by the innermost call to one of the above combinators.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{unique,}{unique,~( element -- )}
}
Adds the element to the end of the sequence being constructed as long as the sequence does not already have an equal element.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{literal,}{literal,~( element -- )}
}
Adds the element wrapped inside a one-element list, then adds the \texttt{car} word. This is used to construct quotations with \texttt{make-list} that must push a word on the stack.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{\%}{\% ( sequence -- )}
}
Appends the subsequence to the end of the sequence being constructed.

Here is an example of sequence construction:
\begin{alltt}
\textbf{ok} : silly [ [ dup , ] repeat ] make-vector , ;
\textbf{ok} [ 4 [ dup silly ] repeat ] make-list .
[ \tto \ttc \tto 0 \ttc \tto 0 1 \ttc \tto 0 1 2 \ttc ]
\end{alltt}

Note that the sequence construction combinators will capture any variables set inside the quotation, due to the dynamic scoping behavior. These combinators are actually implemented using variables. See \ref{namespaces}.

\section{Mappings}

\glossary{name=mapping,
description={an unordered collection of elements, accessed by key. Examples include association lists and hashtables}}

Mappings associate keys with values. The two classes of mappings in the Factor library are association lists and hashtables.

\begin{tabular}[t]{l|c|c|c|l}
Class&Mutable&Ordered&Lookup&Primary purpose\\
\hline
\texttt{assoc}&&$\surd$&$O(n)$&Small, unchanging mappings\\
\texttt{hashtable}&$\surd$&&$O(1)$&Large or frequently-changing mappings
\end{tabular}

It might be tempting to just always use hashtables, however for very small mappings, association lists are just as efficient, and are easier to work with since the entire set of list words can be used with them.

\subsection{Association lists}

\glossary{name=association list,
description={a list of pairs, where the car of each pair is a key and the cdr is the value associated with that key}}

Association lists are built from cons cells. They are structured like a ribbed spine, where the ``spine'' is a list and each ``rib'' is a cons cell holding a key/value pair.

\wordtable{
\vocabulary{lists}
\ordinaryword{assoc?}{assoc ( object -- ?~)}
}
Tests if the object at the top of the stack is a proper list whose every element is a cons.

\wordtable{
\vocabulary{lists}
\ordinaryword{assoc}{assoc ( k alist -- v )}
\ordinaryword{assoc*}{assoc* ( k alist -- [[ k v ]] )}
}
These words look up a key in an association list, comparing keys in the list with the given key by equality with \texttt{=}. The list is searched starting from the beginning. The two words differ in that the latter returns the key/value pair located, whereas the former only returns the value. The \texttt{assoc*} word allows a distinction to be made between a missing value.
\wordtable{
\vocabulary{lists}
\ordinaryword{assq}{assq ( k alist -- v )}
\ordinaryword{assq*}{assq* ( k alist -- [[ k v ]] )}
}
These words compare keys by identity with \texttt{eq?}~and are dual to \texttt{assoc} and \texttt{assoc*}.
\wordtable{
\vocabulary{lists}
\ordinaryword{acons}{acons ( v k alist -- alist )}
\ordinaryword{set-assoc}{set-assoc ( v k alist -- alist )}
}
These words output a new association list containing the key/value pair.
They differ in that \texttt{set-assoc} removes any existing key/value pairs with the given key first. In both cases, searching for the key in the returned association list gives the new value, however with the slightly faster \texttt{acons}, the old value remains shadowed in the list.
\wordtable{
\vocabulary{lists}
\ordinaryword{remove-assoc}{remove-assoc ( k alist -- alist )}

}
Outputs a new association list which does not have any key/value pairs with the key equal to \texttt{k}.

\begin{figure}
\caption{An association list and its graphical representation}
\begin{verbatim}
[
    [[ "Salsa" "Hot" ]]
    [[ "Stir-Fry" "Medium" ]]
    [[ "Peppers" "Very Hot" ]]
]
\end{verbatim}

\begin{center}
\scalebox{0.45}{\epsfig{file=assoc.eps}}
\end{center}
\end{figure}

\subsubsection{Dual representation}

Sometimes it is convenient to decompose an association list into two lists of equal length, containing the keys and values, respectively, in the same order as the association list. This dual representation can be manipulated with a handful of helper words.

\wordtable{
\vocabulary{lists}
\ordinaryword{zip}{zip ( keys values -- alist )}
\ordinaryword{unzip}{unzip ( alist -- keys values )}
}
These words convert between pairs of lists and lists of pairs.
\begin{alltt}
\textbf{ok} [ 1 2 3 ] [ 4 5 6 ] zip .
[ [[ 1 4 ]] [[ 2 5 ]] [[ 3 6 ]] ]
\textbf{ok} [ [[ 1 2 ]] [[ 3 4 ]] [[ 5 6 ]] ] unzip .s
[ 2 4 6 ]
[ 1 3 5 ]
\end{alltt}
\wordtable{
\vocabulary{lists}
\ordinaryword{2cons}{2cons ( car1 car2 cdr1 cdr2 -- c1 c2 )}
}
Cons a pair of elements onto a pair of lists.
\wordtable{
\vocabulary{lists}
\ordinaryword{2car}{2car ( c1 c2 -- car1 car2 )}
\ordinaryword{2cdr}{2cdr ( c1 c2 -- cdr1 cdr2 )}
}
Deconstructs paired lists.

\subsection{\label{hashtables}Hashtables}

\hashglos
\glossary{name=bucket,
description={a container for key/value pairs inside a hashtable. A hash function assigns each key to a bucket, with the goal of spreading the keys as evenly as possible}}
\glossary{name=hashcode,
description={an integer chosen so that equal objects have equal hashcodes, and unequal objects'  hashcodes are distributed as evently as possible}}
\wordtable{
\vocabulary{hashtables}
\classword{hashtable}
}
A hashtable sorts key/value pairs into buckets using a hashing function. The number of buckets is chosen to be approximately equal to the number of key/value pairs in the hashtable, so assuming a good hash function that distributes keys evenly, lookups can be performed in constant time, with a quick hash calculation to determine a bucket, followed by testing of only one or two key/value pairs.
\wordtable{
\vocabulary{kernel}
\genericword{hashcode}{hashcode~( object -- n )}
}
Outputs the hashcode of the object. The contract of this generic word is as follows:
\begin{itemize}
\item The hashcode must be a fixnum\footnote{Strictly speaking, returning a bignum will not fail, however it will result in lower overall performance since the compiler will no longer make type assumptions when compiling callers of \texttt{hashcode}.}
\item If two objects are equal under \texttt{=}, they must have the same hashcode.
\end{itemize}
If mutable objects are used as hashtable keys, they must not be mutated. Doing so will violate bucket sorting invariants and result in undefined behavior.

\wordtable{
\vocabulary{hashtables}
\ordinaryword{hashtable?}{hashtable?~( object -- ?~)}
}
Tests if the object at the top of the stack is a hashtable.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{<hashtable>}{<hashtable>~( n -- hash )}
}
Creates a new empty hashtable with \texttt{n} buckets. As more elements are added to the hashtable, the number of buckets is automatically increased and the keys are re-sorted.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash}{hash ( k hash -- v )}
\ordinaryword{hash*}{hash* ( k hash -- [[ k v ]] )}
}
Looks up the value associated with a key. The two words differ in that the latter returns the key/value pair located, whereas the former only returns the value. The \texttt{hash*} word allows a distinction to be made between a missing value and a value equal to \texttt{f}.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{set-hash}{set-hash ( v k hash -- )}
}
Stores a hashtable entry associating \texttt{k} with \texttt{v}.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{remove-hash}{remove-hash ( k hash -- )}
}
Removes the entry, if any, associated with the key \texttt{k}.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash-clear}{hash-clear ( hash -- )}
}
Removes all entries from the hashtable.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash-size}{hash-size ( hash -- n )}
}
Outputs the number of key/value pairs in the hashtable.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{bucket-count}{bucket-count ( hash -- n )}
}
Outputs the number of buckets in the hashtable. Ideally, this will be approximately equal to, or greater than \texttt{hash-size}.

\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash-each}{hash-each ( hash quot -- )}
\texttt{quot:~[[ key value ]] --}\\
}
Applies the quotation to each key/value pair in the hashtable.

\subsubsection{Converting between mappings}

\wordtable{
\vocabulary{hashtables}
\ordinaryword{alist>hash}{alist>hash ( assoc -- hash )}
}
Creates a hashtable with the same key/value pairs as the association list. If the association list contains duplicate keys, latter keys take precedence; this behavior is the opposite of the \texttt{assoc} word, where prior keys take precedence.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash>alist}{hash>alist ( hash -- assoc )}
}
Creates an association list with the same key/valie pairs as the hashtable.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash-keys}{hash-keys ( hash -- list )}
\ordinaryword{hash-values}{hash-values ( hash -- list )}
}
Builds lists of keys and values stored in the hashtable.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{buckets>list}{buckets>list ( hash -- list )}
}
Outputs a list of association lists, where each association list contains the key/value pairs in a certain bucket. Useful for debugging hashcode distribution.

\subsubsection{Hashtable construction}

A facility analogous to sequence construction (\ref{make-seq}) exists for hashtables.

\wordtable{
\vocabulary{hashtables}
\ordinaryword{make-hash}{make-hash ( quot -- hash )}
}
Calls the quotation in a new dynamic scope. The quotation and any words it calls can execute the \texttt{hash,} word to add key/value pairs to the hashtable being constructed.
\wordtable{
\vocabulary{hashtables}
\ordinaryword{hash,}{hash,~( value key -- )}
}
Adds a key/value pair to the hashtable currently being constructed.

As with sequence construction, care must be taken to mind the effects of dynamic scoping on variable assignment performed by the quotation. Details are in \ref{namespaces}.

\subsection{\label{namespaces}Variables and namespaces}

A variable is an entry in a hashtable of bindings, with the hashtable being implicit rather than passed on the stack. These hashtables are termed \emph{namespaces}. Nesting of scopes is implemented with a search order on namespaces, defined by a \emph{name stack}. Since namespaces are just hashtables, any object can be used as a variable, however by convention, variables are keyed by symbols (\ref{symbols}). 

The \texttt{get} and \texttt{set} words read and write variable values. The \texttt{get} word searches up the chain of nested namespaces, while \texttt{set} always sets variable values in the current namespace only. Namespaces are dynamically scoped; when a quotation is called from a nested scope, any words called by the quotation also execute in that scope.

\glossary{name=name stack,
description={a stack holding namespaces. Entering a dynamic scope pushes the name stack, leaving a scope pops it}}
\glossary{name=namespace,
description={a hashtable pushed on the name stack and used as a set of variable bindings}}
\glossary{name=current namespace,
description={the namespace at the top of the name stack}}
\wordtable{
\vocabulary{namespaces}
\ordinaryword{get}{get ( variable -- value )}

}
Searches the name stack for a namespace containing \texttt{variable}, and outputs the value. If no such namespace is found, outputs \texttt{f}.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{set}{set ( value variable -- )}
}
Sets the value of \texttt{variable} to \texttt{value} in the current namespace at the top of the name stack.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{on}{on ( variable -- )}
\ordinaryword{off}{off ( variable -- )}
}
Sets the value of \texttt{variable} to \texttt{t} and \texttt{f} respectively, implemented as follows:
\begin{verbatim}
: on ( variable -- ) t swap set ;
: off ( variable -- ) f swap set ;
\end{verbatim}
\wordtable{
\vocabulary{namespaces}
\ordinaryword{change}{change ( variable quot -- )}
\texttt{quot:~old -- new}\\
}
Applies the quotation to the current variable value, and stores the return value of the quotation back in the variable.
\begin{figure}
\caption{Dynamic scope example}
The following diagram shows the nesting of scopes resulting inside the \texttt{inner} word call resulting from executing \texttt{outer}.
\begin{verbatim}
SYMBOL: rand
SYMBOL: rator
SYMBOL: gator

: inner ( -- )
    rand get gator get * rator set ;
: middle ( -- )
    5 rator set [ inner ] with-scope rator get ;
: outer ( -- )
    2 gator set
    3 rand set
    [ 4 rand set middle ] with-scope ;

outer
\end{verbatim}
\begin{center}
\scalebox{0.5}{\epsfig{file=namestack.eps}}
\end{center}
\end{figure}
\wordtable{
\vocabulary{namespaces}
\ordinaryword{with-scope}{with-scope ( quot -- )}
}
Calls the quotation in a new dynamic scope. Any variables set by the quotation are discarded when it returns.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{<namespace>}{<namespace> ( -- ns )}
}
Creates a hashtable with a certain default size.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{bind}{bind ( ns quot -- )}
\ordinaryword{extend}{extend ( ns quot -- namespace )}
}
Calls the quotation in the dynamic scope of \texttt{ns}. When variables are looked up by the quotation, \texttt{ns} is checked first, and setting variables in the quotation stores them in \texttt{ns}. The \texttt{extend} word places the namespace back on the data stack when the quotation returns.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{namespace}{namespace ( -- ns )}
}
Outputs the current namespace.
Sets the value of \texttt{variable} to \texttt{t} and \texttt{f}, respectively.
\wordtable{
\vocabulary{namespaces}
\ordinaryword{global}{global ( -- ns )}
}
Outputs the global namespace. Most often this is used as a parameter to \texttt{bind}. For example, a global variable is set as follows:
\begin{verbatim}
SYMBOL: the-boss
global [ "Mr. Lahey" the-boss set ] bind
\end{verbatim}
\wordtable{
\vocabulary{namespaces}
\ordinaryword{nest}{nest ( variable -- ns )}
}
If the variable is set in the current namespace, outputs its value. Otherwise sets its value to a new namespace and output that.

\section{Mathematics}

\numberglos

\begin{figure}
\caption{Numerical class hierarchy}
\begin{center}
\scalebox{0.5}{\epsfig{file=number.eps}}
\end{center}
\end{figure}

Factor attempts to preserve natural mathematical semantics for numbers. Multiplying two large integers never results in overflow, and dividing two integers yields an exact fraction rather than a floating point approximation. Floating point numbers are also supported, along with complex numbers.

\subsection{Number protocol}

The following usual operations are supported by all numbers.

\wordtable{
\vocabulary{math}
\ordinaryword{+}{+ ( n n -- n )}
\ordinaryword{-}{- ( n n -- n )}
\ordinaryword{*}{* ( n n -- n )}
\ordinaryword{/}{/ ( n n -- n )}
}
The non-commutative operations \texttt{-} and \texttt{/} take operands from the stack in the natural order; \texttt{6 2 /} divides 6 by 2.

\wordtable{
\vocabulary{math}
\ordinaryword{/i}{/i ( n n -- integer )}
\ordinaryword{/f}{/f ( n n -- float )}
}
The \texttt{/} word gives an exact answer where possible. These two words output the answer in other forms. The \texttt{/i} word truncates the result towards zero, and \texttt{/f} converts it to a floating point approximation.
\wordtable{
\vocabulary{math}
\ordinaryword{\^}{\^{} ( x y -- z )}

}
Raises \texttt{x} to the power of \texttt{y}. If \texttt{y} is an integer the answer is computed exactly, otherwise a floating point approximation is used.

The following ordering operations are supported on real numbers only.

\wordtable{
\vocabulary{math}
\ordinaryword{<}{< ( n n -- ?~)}
\ordinaryword{<=}{<= ( n n -- ?~)}
\ordinaryword{>}{> ( n n -- ?~)}
\ordinaryword{>=}{>= ( n n -- ?~)}
}

\subsection{\label{integers}Integers}

\integerglos

\wordtable{
\vocabulary{math}
\classword{integer}
\classword{fixnum}
\classword{bignum}
}
The simplest type of number is the integer. Integers come in two varieties -- \emph{fixnums} and \emph{bignums}. As their names suggest, a fixnum is a fixed-width quantity\footnote{On 32-bit systems, an element of the interval $(-2^{-29},2^{29}]$, and on 64-bit systems, the interval $(-2^{-61},2^{61}]$. Because fixnums automatically grow to bignums, usually you do not have to worry about details like this.}, and is a bit quicker to manipulate than an arbitrary-precision bignum.

\wordtable{
\vocabulary{math}
\predword{integer?}
\predword{fixnum?}
\predword{bignum?}
}
The predicate word \texttt{integer?}~tests if the top of the stack is an integer. If this returns true, then exactly one of \texttt{fixnum?}~or \texttt{bignum?}~would return true for that object. Usually, your code does not have to worry if it is dealing with fixnums or bignums.

Integer operations automatically return bignums if the result would be too big to fit in a fixnum. Here is an example where multiplying two fixnums returns a bignum:

\begin{alltt}
\textbf{ok} 134217728 fixnum? .
\textbf{t}
\textbf{ok} 128 fixnum? .
\textbf{t}
\textbf{ok} 134217728 128 * .
\textbf{17179869184}
\textbf{ok} 134217728 128 * bignum? .
\textbf{t}
\end{alltt}

Integers can be entered using a different base; see \ref{integer-literals}.

The word \texttt{.} prints numbers in decimal, regardless of how they were input. A set of words in the \texttt{prettyprint} vocabulary is provided to print integers using another base.

\wordtable{
\vocabulary{prettyprint}
\ordinaryword{.h}{.h ( n -- )}
\ordinaryword{.o}{.o ( n -- )}
\ordinaryword{.b}{.b ( n -- )}

}
Prints an integer in hexadecimal, octal or binary.

\subsubsection{Counted loops}

A pair of combinators calls a quotation a fixed number of times.

\wordtable{
\vocabulary{math}
\ordinaryword{times}{times ( n quot -- )}
\texttt{quot:~-- }\\
}
Calls the quotation $n$ times. If $n<0$, the quotation is not called at all.

\wordtable{
\vocabulary{math}
\ordinaryword{repeat}{repeat ( n quot -- )}
\texttt{quot:~i -- i }\\
}
Calls \texttt{quot} $n$ times, with the parameter \texttt{i} ranging from 0 to $n-1$. The quotation must output $i$ unmodified; or indeed, if it modifies it, the loop continues from that index. That is, the value $i$ on the stack is the actual loop counter, not a copy.

\subsubsection{Modular arithmetic}

\wordtable{
\vocabulary{math}
\ordinaryword{mod}{mod ( x y -- r )}
}
Computes the remainder of dividing \texttt{x} by \texttt{y}. If the result is 0, then \texttt{x} is a multiple of \texttt{y}.
\begin{alltt}
\textbf{ok} 100 3 mod .
\textbf{1}
\textbf{ok} -546 34 mod .
\textbf{-2}
\end{alltt}
\wordtable{
\vocabulary{math}
\ordinaryword{rem}{rem ( x y -- r )}
}
This is the same as \texttt{mod} except the answer is always positive.
\begin{alltt}
\textbf{ok} -546 34 rem .
\textbf{32}
\end{alltt}

\wordtable{
\vocabulary{math}
\ordinaryword{/mod}{/mod ( x y -- q r )}
}
Computes both the quotient and remainder. That is, \texttt{/mod} could be defined as follows, except in practice it is slightly more efficient:
\begin{verbatim}
: /mod ( x y -- q r ) dup /i swap mod ;
\end{verbatim}
\wordtable{
\vocabulary{math}
\ordinaryword{gcd}{gcd ( x y -- a c )}
}
Applies the Euclidian algorithm to \texttt{x} and \texttt{y}. The output values satisfy the following property for some integer $b$:
$$ax+by=c$$
Furthermore, $c$ is the greatest integer having this property; that is, it is the greatest common divisor of $a$ and $b$.
\wordtable{
\vocabulary{math}
\ordinaryword{mod-inv}{gcd ( x n -- y )}
}
Computes a value \texttt{y} that satisfies the following property:
$$xy \equiv 1 \bmod{n}$$ An exception is thrown if no such \texttt{y} exists.
\wordtable{
\vocabulary{math}
\ordinaryword{\^{}mod}{\^{}mod ( x y n -- z )}
}
Raises \texttt{x} to the power of \texttt{y}, modulo \texttt{n}. This is far more efficient than first calling \texttt{\^{}} followed by \texttt{mod}.

\subsubsection{\label{bitwise}Bitwise operations}

There are two ways of looking at an integer -- as a mathematical entity, or as a string of bits. The latter representation motivates \emph{bitwise operations}.
\wordtable{
\vocabulary{math}
\ordinaryword{bitand}{bitand ( x y -- z )}
}
Outputs a new integer where each bit is set if and only if the corresponding bit is set in both $x$ and $y$.
\begin{alltt}
BIN: 101 BIN: 10 bitand .b
\emph{0}
BIN: 110 BIN: 10 bitand .b
\emph{10}
\end{alltt}
\wordtable{
\vocabulary{math}
\ordinaryword{bitor}{bitor ( x y -- z )}
}
Outputs a new integer where each bit is set if and only if the corresponding bit is set in at least one of $x$ or $y$.
\begin{alltt}
BIN: 101 BIN: 10 bitor .b
\emph{111}
BIN: 110 BIN: 10 bitor .b
\emph{110}
\end{alltt}
\wordtable{
\vocabulary{math}
\ordinaryword{bitxor}{bitxor ( x y -{}- x\^{}y )}
}
Outputs a new integer where each bit is set if and only if the corresponding bit is set in exactly one of $x$ or $y$.
\begin{alltt}
BIN: 101 BIN: 10 bitxor .b
\emph{111}
BIN: 110 BIN: 10 bitxor .b
\emph{100}
\end{alltt}
\wordtable{
\vocabulary{math}
\ordinaryword{bitnot}{bitnot ( x -{}- y )}
}
Computes the bitwise complement of the input; that is, each bit in the input number is flipped. Because integers are represented in two's complement form, this is actually equivalent to negating the integer, and subtracting 1.
\wordtable{
\vocabulary{math}
\ordinaryword{shift}{shift ( x n -{}- y )}
}
Computes a new integer consisting of the bits of the first integer, shifted to the left by $n$ positions. If $n$ is negative, the bits are shifted to the right instead, and bits that ``fall off'' are discarded.
\begin{alltt}
BIN: 101 5 shift .b
\emph{10100000}
BIN: 11111 -2 shift .b
\emph{111}
\end{alltt}

\subsubsection{Generating random numbers}

\wordtable{
\vocabulary{math}
\ordinaryword{random-int}{random-int ( a b -- n )}
}
Outputs a pseudo-random integer in the interval $[a,b]$.

\subsection{\label{ratios}Rational numbers}

\newcommand{\rationalglos}{\glossary{
name=rational,
description={an instance of the \texttt{rational} class, which is a disjoint union of the
\texttt{integer} and \texttt{ratio} classes}}}
\rationalglos
\ratioglos

\wordtable{
\vocabulary{math}
\classword{ratio}
}
If we add, subtract or multiply any two integers, the result is always an integer. However, this is not the case with division. When dividing a numerator by a denominator where the numerator is not a integer multiple of the denominator, a ratio is returned instead.
\begin{alltt}
1210 11 / .
\emph{110}
100 330 / .
\emph{10/33}
\end{alltt}
Ratios are printed and can be input literally in the form above. Ratios are always reduced to lowest terms by factoring out the greatest common divisor of the numerator and denominator. A ratio with a denominator of 1 becomes an integer. Trying to create a ratio with a denominator of 0 raises an error.

Ratios behave just like any other number -- all numerical operations work as expected.
\begin{alltt}
\textbf{ok} 1/2 1/3 + .
\textbf{5/6}
\textbf{ok} 100 6 / 3 * .
\textbf{50}
\end{alltt}
\wordtable{
\vocabulary{math}
\predword{ratio?}
}
Tests if the top of the stack is a ratio.
\wordtable{
\vocabulary{math}
\ordinaryword{numerator}{numerator ( rational -- numerator )}
\ordinaryword{denominator}{denominator ( rational -- numerator )}
}
Deconstructs rational numbers into their numerator and denominator. The denominator is always positive; for integers, it equals 1.
\begin{alltt}
\textbf{ok} 75/33 numerator .
\textbf{25}
\textbf{ok} 75/33 denominator .
\textbf{11}
\textbf{ok} 12 numerator .
\textbf{12}
\end{alltt}

\subsection{\label{floats}Floating point numbers}

\wordtable{
\vocabulary{math}
\classword{float}
}
\newcommand{\realglos}{\glossary{
name=real,
description={an instance of the \texttt{real} class, which is a disjoint union of the
\texttt{rational} and \texttt{float} classes}}}
\realglos
\floatglos

Rational numbers represent \emph{exact} quantities. On the other hand, a floating point number is an \emph{approximation}. While rationals can grow to any required precision, floating point numbers are fixed-width, and manipulating them is usually faster than manipulating ratios or bignums (but slower than manipulating fixnums). Floating point literals are often used to represent irrational numbers, which have no exact representation as a ratio of two integers. Floating point literals are input with a decimal point.

\begin{alltt}
\textbf{ok} 1.23 1.5 + .
\textbf{1.73}
\end{alltt}

Introducing a floating point number in a computation forces the result to be expressed in floating point.

\begin{alltt}
\textbf{ok} 5/4 1/2 + .
\textbf{7/4}
\textbf{ok} 5/4 0.5 + .
\textbf{1.75}
\end{alltt}

\wordtable{
\vocabulary{math}
\predword{float?}
}
Tests if the top of the stack is a floating point number.
\wordtable{
\vocabulary{math}
\ordinaryword{>float}{>float ( real -- float )}
}
Turn any real number into a floating point approximation.

\subsection{\label{complex-numbers}Complex numbers}

\wordtable{
\vocabulary{math}
\classword{complex}
}
Complex numbers arise as solutions to quadratic equations whose graph does not intersect the $x$ axis. Their literal syntax is covered in \ref{complex-literals}.

\wordtable{
\vocabulary{math}
\predword{complex?}
}
Tests if the top of the stack is a complex number. Note that unlike math, where all real numbers are also complex numbers, Factor only considers a number to be a complex number if its imaginary part is non-zero.

\wordtable{
\vocabulary{math}
\ordinaryword{real}{real ( n -- n )}
\ordinaryword{imaginary}{imaginary ( n -- n )}
}
Deconstructs complex numbers into their real and imaginary components. The imaginary component of a real number is always zero.
\begin{alltt}
\textbf{ok} -1 sqrt real .
\textbf{0}
\textbf{ok} -1 sqrt imaginary .
\textbf{1}
\end{alltt}
\wordtable{
\vocabulary{math}
\ordinaryword{>rect}{>rect ( n -- re im )}
\ordinaryword{rect>}{rect> ( re im -- n )}
}
Converts between complex numbers and pairs of real numbers representing them in rectangular form.
\begin{alltt}
\textbf{ok} -1 sqrt sqrt >rect .s
\textbf{0.7071067811865475
0.7071067811865476}
\textbf{ok} 1/3 5 rect> .
\textbf{\#\tto 1/3 5 \ttc\#}
\end{alltt}

\wordtable{
\vocabulary{math}
\ordinaryword{>polar}{>polar ( n -- r theta )}
\ordinaryword{polar>}{polar> ( r theta -- n )}
}
Converts between complex numbers and pairs of real numbers representing them in polar form. The polar form of a complex number consists of an absolute value and argument.
\begin{alltt}
\textbf{ok} \#\tto 4 5 \ttc >polar .s
\textbf{0.8960553845713439
6.403124237432849}
\end{alltt}

\wordtable{
\vocabulary{math}
\ordinaryword{abs}{abs ( n -- r )}
\ordinaryword{arg}{arg ( n -- theta )}

}
Computes the absolute value and argument individually.
\begin{alltt}
\textbf{ok} -5.3 abs .
\textbf{5.3}
\textbf{ok} i arg .
\textbf{1.570796326794897}
\end{alltt}

\subsection{Algebraic and transcedential functions}

\wordtable{
\vocabulary{math}
\ordinaryword{sq}{sq ( x -- y )}
\ordinaryword{sqrt}{sqrt ( x -- y )}
\ordinaryword{recip}{recip ( x -- y )}
}
Computes the square (power of 2), square root (power of $\frac{1}{2}$), and reciprocal (power of $-1$).
\wordtable{
\vocabulary{math}
\ordinaryword{exp}{exp ( n -- n )}
}
Raises the number $e$\footnote{Approximately equal to $2.718281828459045$} to a specified power. The number $e$ can be pushed on the stack with the \texttt{e} word, so \texttt{exp} could have been defined as follows:

\begin{alltt}
: exp ( x -- y ) e swap \^ ;
\end{alltt}

However, it is actually defined otherwise, for efficiency.\footnote{In fact, things are done the other way around; the word \texttt{\^{}} is actually defined in terms of \texttt{exp}, to correctly handle complex number arguments.}
\wordtable{
\vocabulary{math}
\ordinaryword{log}{log ( x -- y )}
}
Computes the natural (base $e$) logarithm. This is the inverse of the \texttt{exp} function.
\begin{alltt}
\textbf{ok} e log .
\textbf{1.0}
\textbf{ok} -1 log .
\textbf{\#\tto 0.0 3.141592653589793 \ttc}
\end{alltt}
The \texttt{math} vocabulary provides the full set of trigonometric and hyperbolic functions, along with inverses and reciprocals. Complex number arguments are supported.

\begin{tabular}{l|l|l|l|l}
Function&Trigonometric&Hyperbolic&Trig. inverse&Hyp. inverse\\
\hline
Sine&\texttt{sin}&\texttt{sinh}&\texttt{asin}&\texttt{asinh}\\
Cosine&\texttt{cos}&\texttt{cosh}&\texttt{acos}&\texttt{acosh}\\
Tangent&\texttt{tan}&\texttt{tanh}&\texttt{atan}&\texttt{atanh}\\
\hline
Cosecant&\texttt{cosec}&\texttt{cosech}&\texttt{acosec}&\texttt{acosech}\\
Secant&\texttt{sec}&\texttt{sech}&\texttt{asec}&\texttt{asech}\\
Cotangent&\texttt{cot}&\texttt{coth}&\texttt{acot}&\texttt{acoth}
\end{tabular}

\subsection{Constants}

The following words in the \texttt{math} vocabulary push constant values on the stack.

\begin{tabular}{l|l}
Word&Value\\
\hline
\texttt{i}&Positive imaginary unit -- \texttt{\pound\tto 0 1 \ttc\pound}\\
\texttt{-i}&Negative imaginary unit -- \texttt{\pound\tto 0 -1 \ttc\pound}\\
\texttt{inf}&Positive floating point infinity\\
\texttt{-inf}&Negative floating point infinity\\
\texttt{e}&Base of natural logarithm ($e\approx 2.7182818284590452354$)\\
\texttt{pi}&Ratio of circumference to diameter ($\pi\approx 3.14159265358979323846$)\\
\texttt{pi/2}&$\frac{\pi}{2}\approx 1.5707963267948966$
\end{tabular}

\section{Streams}
\glossary{name=stream,
description={a source or sink of characters supporting some subset of the stream protocol, used as an end-point for input/output operations}}

Input and output is centered around the concept of a \emph{stream}, which is a source or
sink of characters. Streams also support formatted output, which may be used to present styled text in a manner independent of output medium. A few stream implementations are provided by the library.

\begin{description}
\item[File streams] read and write local files.
\item[Network streams] connect to servers and accept connections from clients.
\item[HTML streams] implement the formatted output protocol to generate HTML from styled text attributes, then direct the HTML to an underlying stream.
\item[Duplex streams] combine an input and output stream into a single bidirectional stream.
\item[Null streams] return end of file on input, and ignore output.
\end{description}

String buffers support the stream output protocol. See \ref{stdio}.

\subsection{\label{stream-protocol}Stream protocol}
\glossary{name=input stream,
description={a stream that implements the \texttt{stream-readln} and \texttt{stream-read} generic words and can be used for character input}}
\glossary{name=output stream,
description={a stream that implements the \texttt{stream-write-attr}, \texttt{stream-flush} and \texttt{stream-auto-flush} generic words and can be used for character output}}

There are various subsets of the stream protocol that a class can implement so that its instances may be used as streams. The following generic word is mandatory.

\wordtable{
\vocabulary{streams}
\genericword{stream-close}{stream-close ( s -- )}
}
Releases any external resources associated with the stream, such as file handles and network connections. No further operations can be performed on the stream after this call.

You must close streams after you are finished working with them. A convenient way to automate this is by using the \texttt{with-stream} word in \ref{stdio}.

The following two words are optional, and should be implemented on input streams.
\wordtable{
\vocabulary{streams}
\genericword{stream-readln}{stream-readln ( s -- str/f )}
}
Reads a line of text and outputs it on the stack. If the end of the stream has been reached, outputs \texttt{f}. The precise meaning of a ``line'' depends on the stream; with file and network streams, it is a range of characters terminated by \verb|\n|, \verb|\r| or \verb|\r\n|.
\wordtable{
\vocabulary{streams}
\genericword{stream-read}{stream-read ( n s -- str )}
}
Reads \texttt{n} characters from the stream. If less than \texttt{n} characters are available before the end of the stream, a shorter string is output.

The following three words are optional, and should be implemented on output streams.

\wordtable{
\vocabulary{streams}
\genericword{stream-write-attr}{stream-write-attr ( str/ch attrs s -- )}
}
Outputs a character or string to the stream. This might not result in immediate output to the underlying resource if the stream performs buffering, like all file and network streams do. 

The \texttt{attrs} parameter is an association list holding style information, and it is ignored by most streams -- one exception is HTML streams (\ref{html}). Most of the time either the \texttt{stream-write} or \texttt{stream-print} word is used. They are described in the next section.

\wordtable{
\vocabulary{streams}
\genericword{stream-flush}{stream-flush ( s -- )}
}
Ensures all pending output operations are been complete. With many output streams, written output is buffered and not sent to the underlying resource until either the buffer is full, or an explicit call to \texttt{stream-flush} is made.

\wordtable{
\vocabulary{streams}
\genericword{stream-auto-flush}{stream-auto-flush ( s -- )}
}
Ensures the user sees prior output. It is not as strong as \texttt{stream-flush}. The contract is as follows: if the stream is connected to an interactive end-point such as a terminal, \texttt{stream-auto-flush} should execute \texttt{stream-flush}. If the stream is a file or network stream used for ``batch'' operations, this word should have an empty definition.

The \texttt{stream-print} word executes \texttt{stream-auto-flush} after each line of output.

With some streams, the above operations may suspend the current thread and execute other threads until input data is available (\ref{threads}).

\subsection{Stream utilities}

The following three words are implemented in terms of the stream protocol, and should work with any stream supporting the required underlying operations.
\wordtable{
\vocabulary{streams}
\ordinaryword{stream-read1}{stream-read1 ( stream -- ch/f )}

}
Reads a single character using \texttt{stream-read} and outputs the character. If the end of the stream has been reached, outputs \texttt{f}.
\wordtable{
\vocabulary{streams}
\ordinaryword{stream-write}{stream-write ( string stream -- )}

}
Outputs a character or string to the stream, without any specific style information. Implemented as follows:
\begin{verbatim}
: stream-write ( string stream -- )
    f swap stream-write-attr ;
\end{verbatim}
\wordtable{
\vocabulary{streams}
\ordinaryword{stream-print}{stream-print ( string stream -- )}

}
Outputs a character or string to the stream, followed by a newline, then executes \texttt{stream-auto-flush} to force the line to be displayed on interactive streams.

\subsection{\label{stdio}The default stream}
\glossary{name=default stream,
description={the value of the \texttt{stdio} variable, used by various words as an implicit stream parameter}}
\glossary{name=stdio,
description={see default stream}}
Various words take an implicit stream parameter from the \texttt{stdio} variable to reduce stack shuffling.
\wordtable{
\vocabulary{stdio}
\ordinaryword{close}{close ( -- )}

}
\begin{verbatim}
: close stdio get stream-close ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{read-line}{read-line ( -- str/f )}

}
\begin{verbatim}
: read-line stdio get stream-readln ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{read}{read ( n -- str )}

}
\begin{verbatim}
: read stdio get stream-read ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{read1}{read1 ( n -- str )}

}
\begin{verbatim}
: read1 stdio get stream-read1 ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{write}{write ( str -- )}

}
\begin{verbatim}
: write stdio get stream-write ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{write-attr}{write-attr ( str attrs -- )}

}
\begin{verbatim}
: write-attr stdio get stream-write-attr ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{print}{print ( str -- )}

}
\begin{verbatim}
: print stdio get stream-print ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{terpri}{terpri ( -- )}

}
\begin{verbatim}
: terpri "\n" stdio get stream-write ;
\end{verbatim}
\wordtable{
\vocabulary{stdio}
\ordinaryword{flush}{flush ( -- )}

}
\begin{verbatim}
: flush stdio get stream-flush ;
\end{verbatim}

The value of the \texttt{stdio} variable can be rebound inside a quotation with the following combinators.

\wordtable{
\vocabulary{stdio}
\ordinaryword{with-stream}{with-stream ( stream quot -- )}
}
Calls the quotation in a new dynamic scope, with the \texttt{stdio} variable set to \texttt{stream}. The stream is closed when the quotation returns or if an exception
is thrown.
\wordtable{
\vocabulary{stdio}
\ordinaryword{with-stream*}{with-stream* ( stream quot -- )}
}
Like \verb|with-stream| extend the stream is only closed in the case of an error.

\wordtable{
\vocabulary{stdio}
\ordinaryword{with-string}{with-string ( quot -- string )}

}
Calls the quotation in a new dynamic scope, with the \texttt{stdio} variable set to a new string buffer. Executing \texttt{write}, \texttt{write-attr} or \texttt{print} will append text to the string buffer. When the quotation returns, the string buffer is coverted to
a string and returned.

\subsection{Reading and writing files}

\glossary{name=file reader,
description=an input stream reading from a file}
\glossary{name=file writer,
description=an output stream writing to a file}
\wordtable{
\vocabulary{streams}
\ordinaryword{<file-reader>}{<file-reader> ( path -- stream )}

}
Opens the file for reading and returns an input stream. An exception is thrown if the file could not be opened.
\wordtable{
\vocabulary{streams}
\ordinaryword{<file-writer>}{<file-writer> ( path -- stream )}

}
Opens the file for writing and returns an output stream. An exception is thrown if the file could not be opened.

The following set of words provide access to file system metadata.

\wordtable{
\vocabulary{files}
\ordinaryword{file-extension}{file-extension~( path -- string/f )}

}
Outputs the remainder of the file's name after the last occurrence of a period, or \texttt{f} if there is no extension.
\begin{alltt}
\textbf{ok} "world.takeover.plan.txt" file-extension .
\textbf{"txt"}
\end{alltt}
\wordtable{
\vocabulary{files}
\ordinaryword{exists?}{exists?~( path -- ?~)}

}
Tests if a file exists.
\wordtable{
\vocabulary{files}
\ordinaryword{directory?}{directory?~( path -- ?~)}

}
Tests if a file is a directory. Outputs \texttt{f} if the file does not exist..
\wordtable{
\vocabulary{files}
\ordinaryword{file-length}{file-length~( path -- n/f~)}

}
Outputs the size of the file, or \texttt{f} if it does not exist.
\wordtable{
\vocabulary{files}
\ordinaryword{stat}{stat~( path -- list~)}

}
Outputs a list of file system attributes, or \texttt{f} if the file does not exist. The elements of the list are the following:
\begin{description}
\item[Directory flag] a boolean
\item[Length] an integer
\item[Permissions] on Unix, a standard \texttt{chmod}-style permission bitmap
\item[Last modification time] milliseconds since midnight, January 1st 1970 GMT
\end{description}

\subsection{TCP/IP networking}

\glossary{name=server stream,
description=a stream listening on a TCP/IP socket}
\glossary{name=client stream,
description=a bidirectional stream for an to end-point of a TCP/IP connection}
\wordtable{
\vocabulary{streams}
\ordinaryword{<client>}{<client>~( host port -- stream~)}

}
Connects to TCP/IP port number \texttt{port} on the host named by \texttt{host}, and returns a bidirectional stream. An exception is thrown if the connection attempt fails.
\wordtable{
\vocabulary{streams}
\ordinaryword{<server>}{<server>~( port -- server~)}

}
Begins listening for connections to \texttt{port} on all network interfaces. An exception is thrown if the port cannot be opened. The returned object can be used as an input to the \texttt{stream-close} and \texttt{accept} words.
\wordtable{
\vocabulary{streams}
\ordinaryword{accept}{accept~( server -- stream~)}

}
Waits for a connection to the port number that \texttt{server} is listening on, and outputs a bidirectional stream when the connection has been established.  An exception is thrown if an error occurs.
\wordtable{
\vocabulary{streams}
\ordinaryword{client-stream-host}{client-stream-host~( stream -- port~)}
\ordinaryword{client-stream-port}{client-stream-port~( stream -- port~)}

}
Outputs the IP address as a dotted-quad string, and the local port number, respectively, of a client socket returned from \texttt{accept}.

\subsection{Special streams}

\glossary{name=null stream,
description=a bidirectional stream that ignores output and returns end of file on input}
\glossary{name=duplex stream,
description=a bidirectional delegating to an input stream for input and an output stream for output}
\glossary{name=wrapper stream,
description=a bidirectional stream delegating to an underlying stream and providing a namespace where the delegated stream is the default stream}

\wordtable{
\vocabulary{streams}
\ordinaryword{<null-stream>}{<null-stream>~( -- stream~)}
}
Creates a null stream, which ignores output written to it, and returns end of file if an attempt is made to read.
\wordtable{
\vocabulary{streams}
\ordinaryword{<duplex-stream>}{<duplex-stream>~( in out -- stream~)}
}
Creates a duplex stream. Writing to a duplex stream will write to \texttt{out}, and reading from a duplex stream will read from \texttt{in}. Closing a duplex stream closes both the input and output streams.
\wordtable{
\vocabulary{streams}
\ordinaryword{<wrapper-stream>}{<wrapper-stream>~( stream -- stream~)}
}
Creates a stream wrapping \texttt{stream}. The given stream becomes the delegate of the new wrapper stream, so calling any stream operation on the wrapper passes it on to the delegate.
You can then define your own tuple class that delegates to a wrapper stream, then override methods on this new tuple class, and use the following combinator in your method definitions.

\wordtable{
\vocabulary{streams}
\ordinaryword{with-wrapper}{with-wrapper~( stream quot -- ~)}
}
Executes the quotation in a dynamic scope where the \texttt{stdio} variable is set to the wrapped stream.

The following example implements a stream that emits \TeX\ markup when a certain attribute is set in the \texttt{attrs} parameter to \texttt{stream-write-attr}.

\begin{verbatim}
USING: generic kernel lists stdio streams ;
TUPLE: tex-stream ;

C: tex-stream ( stream -- stream )
    [ >r <wrapper-stream> r> set-delegate ] keep ;

M: tex-stream stream-write-attr ( string attrs stream -- )
    [
        "bold" swap assoc [
            "\textbf{" write write "}" write
        ] [
            write
        ] ifte
    ] with-wrapper ;
\end{verbatim}

\subsection{Printing objects}

\glossary{name=prettyprinter,
description={a set of words for printing objects in readable form}}

One of Factor's key features is the ability to print almost any object in a readable form. This greatly aids debugging and provides the building blocks for light-weight object serialization facilities.

\subsubsection{The unparser}

The unparser provides a basic facility for turning certain types of objects into strings. A more general facility supporting more types is the prettyprinter (\ref{prettyprint}).
\glossary{
name=unreadable string,
description={a string which raises a parse error when parsed}}
\glossary{
name=readable form,
description={a readable form of an object is a string that parses to that object}}

\wordtable{
\vocabulary{unparser}
\genericword{unparse}{unparse~( object -- string~)}
}
Outputs a string representation of \texttt{object}. Only the following classes of objects are supported; for anything else, an unreadable string is output:
\begin{verbatim}
boolean
dll
number
sbuf
string
word
\end{verbatim}
A set of words are provided for converting integers into strings with various bases.
\wordtable{
\vocabulary{unparser}
\ordinaryword{>base}{>base~( n base -- string~)}
}
Converts \texttt{n} into a string representation in the given base. The base must be between 2 and 36, inclusive.
\wordtable{
\vocabulary{unparser}
\ordinaryword{>bin}{>bin~( n -- string~)}
\ordinaryword{>oct}{>oct~( n -- string~)}
\ordinaryword{>dec}{>dec~( n -- string~)}
\ordinaryword{>hex}{>hex~( n -- string~)}
}
Convenience words defined in terms of \texttt{>base} for converting integers into string representations in base 2, 8, 10 and 16, respectively.

\subsubsection{\label{prettyprint}The prettyprinter}

\wordtable{
\vocabulary{prettyprint}
\ordinaryword{prettyprint}{prettyprint~( object --~)}

}
Prints the object using literal syntax that can be parsed back again. Even though the prettyprinter supports more classes of objects than \texttt{unparse}, it is still not a general serialization mechanism. The following restrictions apply:

\begin{itemize}
\item Not all objects print in a readable way. Namely, the following classes do not:
\begin{verbatim}
array
byte-array
displaced-alien
\end{verbatim}
\item Circular structure is not printed in a readable way. Circular references are printed as ``\texttt{...}''.
\item Floating point numbers might not equal themselves after being printed and read, since a decimal representation of a float is inexact.
\end{itemize}
\wordtable{
\vocabulary{prettyprint}
\ordinaryword{.}{.~( object --~)}

}
Prettyprint the object, except all output is on a single line without indentation, and deeply-nested structure is not printed fully. This word is intended for interactive use at the listener.
\wordtable{
\vocabulary{prettyprint}
\ordinaryword{[.]}{[.]~( sequence --~)}

}
Prettyprint each element of the sequence on its own line using the \texttt{.} word.

\subsubsection{Variables controlling the prettyprinter}

The following variables affect the prettyprinter if set in the dynamic scope from which \texttt{prettyprint} is called.

\wordtable{
\vocabulary{prettyprint}
\symbolword{tab-size}
}
Specifies the indentation for recursive objects such as lists, vectors, hashtables and tuples. The default tab size is 4.

\wordtable{
\vocabulary{prettyprint}
\symbolword{prettyprint-limit}
}
Controls the maximum nesting depth. Printing structures that nest further than this will simply print ``\texttt{...}''. If this is set to \texttt{f}, the nesting depth is unlimited. The default is \texttt{f}. Inside calls to \texttt{.}, set to 16, which translates to four levels of nesting with the default tab size.

\wordtable{
\vocabulary{prettyprint}
\symbolword{one-line}
}
If set to true, the prettyprinter does not emit newlines. The default is \texttt{f}. Inside calls to \texttt{.}, set to \texttt{t}.

\subsubsection{Extending the prettyprinter}

If define your own data type and wish to add new syntax for it, you must implement two facilities:
\begin{itemize}
\item Parsing word(s) for reading your data type,
\item A prettyprinter method for printing your data type.
\end{itemize}
Parsing words are documented in \ref{parsing-words}.

\wordtable{
\vocabulary{prettyprint}
\genericword{prettyprint*}{prettyprint* ( indent object -- indent )}
}
Prettyprints the given object. Unlike \texttt{prettyprint*}, this word does not emit a trailing newline, and the current indent level is given. This word is also generic, so you can add methods to have it print your own data types in a nice way.

The remaining words in this section are useful in the implementation of prettyprinter methods.
\wordtable{
\vocabulary{prettyprint}
\genericword{word.}{word.~( word -- )}
}
Prints a word. Unlike \texttt{prettyprint*}, does not prefix the word with \texttt{POSTPONE:} in the case that it is a parsing word.
\wordtable{
\vocabulary{prettyprint}
\genericword{prettyprint-newline}{prettyprint-newline ( indent -- )}
}
Emits a newline followed by the given amount of indentation.
\wordtable{
\vocabulary{prettyprint}
\genericword{?prettyprint-newline}{?prettyprint-newline ( indent -- )}
}
If \texttt{one-line} is on, emits a space, otherwise, emits a newline followed by the given amount of indentation.
\wordtable{
\vocabulary{prettyprint}
\genericword{<prettyprint}{<prettyprint~( indent -- indent )}
}
Increases the indent level and emits a newline if \texttt{one-line} is off.
\wordtable{
\vocabulary{prettyprint}
\genericword{prettyprint>}{prettyprint>~( indent -- indent )}
}
Decreases the indent level and emits a newline if \texttt{one-line} is off.

\section{The parser}

This section concerns itself with reflective access and extension of the parser. The parser algorithm and standard syntax is described in \ref{syntax}. Before the parser proper is documented, we draw attention to a set of words for parsing numbers. They are called by the parser, and are useful in their own right.

\subsection{\label{parsing-numbers}Parsing numbers}

\wordtable{
\vocabulary{parser}
\ordinaryword{str>number}{str>number~( string -- number )}
}
Attempts to parse the string as a number. An exception is thrown if the string does not represent a number in one of the following forms:
\begin{itemize}
\item An integer; see \ref{integer-literals}
\item A ratio; see \ref{ratio-literals}
\item A float; see \ref{float-literals}
\end{itemize}
In particular, complex numbers are parsed by the \verb|#{| and \verb|}#| parsing words, not by the number parser. To parse complex number literals, use the \texttt{parse} word (\ref{parsing-quotations}).
\wordtable{
\vocabulary{parser}
\ordinaryword{parse-number}{parse-number~( string -- number/f )}
}
Like \texttt{str>number}, except instead of raising an error, outputs \texttt{f} if the string is not a valid literal number.
\wordtable{
\vocabulary{parser}
\genericword{base>}{base>~( string base -- integer )}
}
Converts a string representation of an integer in the given base into an integer. Throws an exception if the string is not a valid representation of an integer.
\wordtable{
\vocabulary{parser}
\ordinaryword{bin>}{bin>~( string -- integer )}
\ordinaryword{oct>}{oct>~( string -- integer )}
\ordinaryword{dec>}{dec>~( string -- integer )}
\ordinaryword{hex>}{hex>~( string -- integer )}
}
Convenience words defined in terms of \texttt{base>} for parsing integers in base 2, 8, 10 and 16, respectively.

\subsection{\label{parsing-quotations}Parsing quotations}

As documented in \ref{vocabsearch}, the parser looks up words in the vocabulary search path. New word definitions are added to the current vocabulary. These two parameters are stored in a pair of variables (\ref{namespaces}):
\begin{description}
\item[\texttt{"use"}] the vocabulary search path; a list of strings
\item[\texttt{"in"}] the current vocabulary; a string
\end{description}

\wordtable{
\vocabulary{parser}
\genericword{parse}{parse~( string -- list )}
}
Parses the string and outputs a quotation. The vocabulary search path and current vocabulary are taken from the current scope.
\begin{alltt}
\textbf{ok} "1 2 3" parse .
\textbf{[ 1 2 3 ]}
\end{alltt}

\wordtable{
\vocabulary{parser}
\genericword{eval}{eval~( string -- )}
}
Parses a string then calls the resulting quotation.
\begin{alltt}
\textbf{ok} "2 2 + ." eval
\textbf{4}
\end{alltt}
The \texttt{eval} word is defined as follows:
\begin{verbatim}
: eval parse call ;
\end{verbatim}

\subsection{Parsing from streams}

There are two sets of words for parsing input from streams. The first set uses the following initial values for the \texttt{"use"} and \texttt{"in"} variables:

\begin{description}
\item[\texttt{"use"}] \texttt{[ "scratchpad" "syntax" ]}
\item[\texttt{"in"}] \texttt{"scratchpad"}
\end{description}

\wordtable{
\vocabulary{parser}
\genericword{parse-stream}{parse-stream~( name stream -- list )}
}
Parses lines of text from the stream and outputs a quotation. The \texttt{name} parameter identifies the stream in error messages. The stream is closed when the end is reached.

\wordtable{
\vocabulary{parser}
\genericword{parse-file}{parse-file~( path -- list )}
}
Parses the contents of a file and outputs a quotation. Defined as follows:
\begin{verbatim}
: parse-file dup <file-reader> parse-stream ;
\end{verbatim}
\wordtable{
\vocabulary{parser}
\genericword{run-file}{run-file~( path -- list )}
}
Parses the contents of a file and calls the resulting quotation. Defined as follows:
\begin{verbatim}
: run-file parse-file call ;
\end{verbatim}

The next set of stream parsing words takes the vocabulary search path and current vocabulary from the current scope. These words are used to load the \texttt{.factor-rc} file on startup, so that any \texttt{USE:}~and \texttt{USING:}~declarations set in that file take effect in the listener (\ref{listener}).

\wordtable{
\vocabulary{parser}
\genericword{(parse-stream)}{(parse-stream)~( name stream -- list )}
\genericword{(parse-file)}{(parse-file)~( path -- list )}
\genericword{(run-file)}{(run-file)~( path -- )}
}
Like the first set of stream parsing words, except the \texttt{"use"} and \texttt{"in"} variables are taken from the current scope.

\subsection{\label{parsing-words}Parsing words}

\parsingwordglos
Parsing words execute at parse time, and therefore can access and modify the state of the parser, as well as add objects to the parse tree. Parsing words are a difficult concept to grasp, so this section has several examples and explains the workings of some of the parsing words provided in the library.

To define a parsing word, suffix the colon definition with the \texttt{parsing} word.

\wordtable{
\vocabulary{syntax}
\parsingword{parsing}{parsing}
}
Marks the most recently defined word as a parsing word. For example:

\begin{verbatim}
: hello "Hello world" print ; parsing
\end{verbatim}

Now writing \texttt{hello} anywhere will print the message \texttt{"Hello world"} at parse time. Of course, this is a useless definition. In the sequel, we will look into writing useful parsing words that modify parser state.

\subsubsection{Nested structure}

The first thing to look at is how the parse tree is built. When parsing begins, the empty list is pushed on the data stack; whenever the parser algorithm appends an object to the parse tree, it conses the object onto the quotation at the top of the stack. This builds the quotation in reverse order, so when parsing is done, the quotation is reversed before it is called.

Lets look at a simple example; the parsing of \texttt{"1 2 3"}:

\begin{tabular}{l|l|l}
\hline
Token&Stack before&Stack after\\
\hline
\verb|1|&\verb|[ ]|&\verb|[ 1 ]|\\
\verb|2|&\verb|[ 1 ]|&\verb|[ 2 1 ]|\\
\verb|3|&\verb|[ 2 1 ]|&\verb|[ 3 2 1 ]|
\end{tabular}

Once the end of the string has been reached, the quotation is reversed, and the output, as you would expect, is \verb|[ 1 2 3 ]|.

Nested structure is a bit more involved. The basic idea is that parsing words can push an empty list on the stack, then all subsequent tokens are consed onto this quotation, until another parsing word adds this quotation to the quotation underneath.

The following definitions of the \verb|[| and \verb|]| parsing words illustrate the idiom:
\begin{verbatim}
: [ f ; parsing
: ] reverse swons ; parsing
\end{verbatim}

Let us look at how the following string parses:

\begin{verbatim}
"1 [ 2 3 ] 4"
\end{verbatim}

\begin{tabular}{l|l|l|l}
\hline
Token&Stack before&Stack after&Note\\
\hline
\verb|1|&\verb|[ ] [ ]|&\verb|[ ] [ 1 ]|&\\
\textbf{\texttt{[}}&\verb|[ 1 ]|&\verb|[ 1 ] [ ]|&pushes an empty list\\
\verb|2|&\verb|[ 1 ] [ ]|&\verb|[ 1 ] [ 2 ]|&\\
\verb|3|&\verb|[ 1 ] [ 2 ]|&\verb|[ 1 ] [ 3 2 ]|&\\
\textbf{\texttt{]}}&\verb|[ 1 ] [ 3 2 ]|&\verb|[ [ 2 3 ] 1 ]|&calls \verb|reverse swons|\\
\verb|4|&\verb|[ [ 2 3 ] 1 ]|&\verb|[ 4 [ 2 3 ] 1 ]|&
\end{tabular}

Now, the parser reverses the original quotation, and the resulting output is clear:
\begin{verbatim}
[ 1 [ 2 3 ] 4 ]
\end{verbatim}
Data types such as vectors, hashtables and so on are built in a similar way. For example, the vector parsing words are defined as thus:
\begin{verbatim}
: { f ; parsing
: } reverse >vector swons ; parsing
\end{verbatim}
Indeed, any type of object can be added to the parse tree in this fashion.

\subsubsection{\label{reading-ahead}Reading ahead}

\glossary{name=reading ahead,
description=a parsing word reads ahead of it scans following tokens from the input string}
The next idiom to look at is parsing words that read ahead. The first example is the \verb|HEX:| word, documented in \ref{integer-literals}. This word is defined so that the following two lines are equivalent:
\begin{verbatim}
HEX: deadbeef
3735928559
\end{verbatim}
It is defined in terms of a lower-level \texttt{(BASE)} word that takes the numerical base on the data stack, reads the next token from the string, then calls \texttt{base>} (\ref{parsing-numbers}):
\begin{verbatim}
: (BASE) ( base -- ) scan swap base> swons ;
: HEX: 16 (BASE) ; parsing
\end{verbatim}
The key word here is \texttt{scan}.
\wordtable{
\vocabulary{parser}
\ordinaryword{scan}{scan ( -- string )}
}
Outputs the next token as a string, or \texttt{f} if the end of the input has been reached. Advances the parser state to after this token.

The next example of a parsing word we will look at is the \verb|\| word. It reads the next token from the input, and appends code to push that word literally on the stack. That is, the following two phrases both have the effect of pushing the word \verb|+| on the stack, rather than executing it:
\begin{verbatim}
\ +
[ + ] car
\end{verbatim}
We can look at how \verb|\| is implemented:
\begin{verbatim}
: \ scan-word unit swons \ car swons ; parsing
\end{verbatim}
The key word here is \verb|scan-word|. It combines \texttt{scan} word with vocabulary search.
\wordtable{
\vocabulary{parser}
\ordinaryword{scan-word}{scan-word ( -- word )}
}
Reads the next token from the input and looks up a word with this name. If the lookup fails, attempts to parse the word as a number by calling \verb|str>number|.

\subsubsection{Defining words}

\definingwordglos
Defining words add definitions to the dictionary without modifying the parse tree.
The first example to look at is the \verb|SYMBOL:| word. It reads the next token from the input stream, creates a word with that name, and makes it a symbol (\ref{symbols}). The next
example is the common \verb|:| word, which creates a colon definition. First, it reads the
name of the new word, then the definition is built up until \verb|;|. The latter
example will demonstrate building nested structure in defining words.

First, let us look at the \verb|SYMBOL:| word (\ref{symbols}).
\begin{verbatim}
: SYMBOL: CREATE define-symbol ; parsing
\end{verbatim}
The key factor the above definition is \verb|CREATE|, which reads a token from the input and creates a word with that name. This word is then passed to \verb|define-symbol|.

\wordtable{
\vocabulary{parser}
\ordinaryword{CREATE}{CREATE ( -- word )}
}
Reads the next token from the input and creates a word in the current vocabulary with that name. It uses \verb|create-in| to do this (\ref{creating-words}).

The definition of \verb|:| introduces the next idiom, and that is building a quotation and then adding a definition using \verb|;|.
\begin{verbatim}
: :
    CREATE [ define-compound ] [ ]
    "in-definition" on ; parsing
\end{verbatim}
The factors of the word are, in order:
\begin{description}
\item[\texttt{CREATE}] reads the following token and pushes a new word on the stack,
\item[\texttt{[ define-compound ]}] a quotation to be called by \verb|;|,
\item[\texttt{[ ]}] an empty list that the parser will build the colon definition on,
\item[\texttt{"in-definition" on}] sets a flag that subsequent parsing words can query.
\end{description}
While \verb|:| is very specific, \verb|;| is quite general because it takes a quotation pushed by a previous parsing word. You can use \verb|;| in your own parsing words.

\wordtable{
\parsingword{;}{;~( definer parsed -- )}
\texttt{definer:~parsed --}\\
}
Reverses the \verb|parsed| quotation, and passes it as input to the \verb|definer| quotation.
The definition of this word is in some sense dual to \verb|:| even thought it is more general:
\begin{verbatim}
: ; "in-definition" off reverse swap call ; parsing
\end{verbatim}

Suppose we are parsing the following string:
\begin{verbatim}
: sq dup * ;
\end{verbatim}

We can trace the parsing as before.

\begin{tabular}{l|l|l}
\hline
Token&Stack after&Note\\
\hline
\verb|:|&\verb|[ ] sq [ define-compound ] [ ]|&reads the next token\\
\verb|dup|&\verb|[ ] sq [ define-compound ] [ dup ]|\\
\verb|*|&\verb|[ ] sq [ define-compound ] [ * dup ]|&\\
\verb|;|&\verb|[ ]|&reverses and defines
\end{tabular}

The call to the \verb|;| word proceeds as follows:
\begin{description}
\item[\texttt{"in-definition" off}] this variable was switched on by \verb|:|.
\item[\texttt{reverse}] reverses \verb|[ * dup ]| yielding \verb|[ dup * ]|.
\item[\texttt{swap call}] calls \texttt{[ define-compound ]}. Thus, \verb|define-compound| is called to define \verb|sq| as the quotation \verb|[ dup * ]|.
\end{description}

\subsubsection{\label{string-mode}String mode and parser variables}
\stringmodeglos
String mode allows custom parsing of tokenized input. For even more esoteric situations, the input text can be accessed directly.

String mode is controlled by the \verb|string-mode| variable.

\wordtable{
\vocabulary{parser}
\symbolword{string-mode}
}
When enabled, the parser adds tokens to the parse tree as strings. This creates a paradox because further parsing words are not executed while string mode is on. However, if the token \verb|";"| is read, there is a special case that calls the \verb|;| parsing word. This parsing word reverses the quotation at the top of the stack, and calls the quotation underneath it, as usual.

An illustration of this idiom is found in the \verb|USING:| parsing word. It reads a list of vocabularies, terminated by \verb|;|. However, the vocabulary names do not name words, except by coincidence; so string mode is used to read them.
\begin{verbatim}
: USING: 
    string-mode on [
        string-mode off [ use+ ] each
    ] [ ] ; parsing
\end{verbatim}
Make note of the quotation that is left in position for \verb|;| to call. It switches off string mode, so that normal parsing can resume, then adds the given vocabularies to the search path.

If the parser features described in the earlier sections are still insufficient, you can directly access a pair of variables holding parser state:
\begin{description}
\item[\texttt{"line"}] the text being parsed,
\item[\texttt{"col"}] the column number.
\end{description}
The \verb|"col"| variable is implicitly changed the \verb|scan| word (\ref{reading-ahead}), and the following word.
\wordtable{
\vocabulary{parser}
\ordinaryword{until-eol}{until-eol ( -- string )}
}
Outputs the remainder of the line being parsed. The \verb|"col"| variable is set to point to the end of the line.

This word is used to implement end-of-line comments:
\begin{verbatim}
: ! until-eol drop ; parsing
\end{verbatim}

\section{Web framework}

\subsection{HTTP client}

\wordtable{
\vocabulary{http-client}
\ordinaryword{http-get}{http-get ( url -- code headers stream )}
}
Attempts to connect to the server specified in the URL. If the connection fails, an exception is thrown, otherwise the following values are output;
\begin{description}
\item[\texttt{code}] an integer with the HTTP response code; for example, 404 denotes ``file not found'' whereas 200 means ``success''.
\item[\texttt{headers}] an association list of returned headers.
\item[\texttt{stream}] a stream for reading the resource.
\end{description}

\subsection{\label{html}HTML output}

An HTML stream wraps an existing stream. Strings written to the HTML stream have their special characters converted to HTML entities before being passed on to the wrapped stream. Also, the \texttt{attrs} parameter to the \texttt{stream-write-attr} word may be filled out to wrap the text being written in various HTML tags.

\wordtable{
\vocabulary{html}
\ordinaryword{with-html-stream}{with-html-stream ( quot -- )}
}
Calls the quotation in a new dynamic scope. The \texttt{stdio} variable is set to an HTML stream wrapping the previous value of \texttt{stdio}, so calls to \texttt{write}, \texttt{write-attr} and \texttt{print} go through the HTML stream.

\wordtable{
\vocabulary{html}
\ordinaryword{html-document}{html-document ( title quot -- )}
}
Builds on \texttt{with-html-stream} to emit the basic structure of an HTML document, consisting of \texttt{<html>}, \texttt{<head>} and \texttt{<body>} tags. The title is output in two places; a \texttt{<title>} tag  and \texttt{<h1>} tag.

\wordtable{
\vocabulary{html}
\ordinaryword{simple-html-document}{simple-html-document ( title quot -- )}
}
Like \texttt{html-document}, except the output is wrapped inside a \texttt{<pre>} tag.

Calls to \texttt{write-attr} inside a quotation given to one of the above combinators will perform HTML output. The following keys may be set in the \texttt{attrs} association list given to \texttt{write-attr}:

\begin{tabular}{l|l}
Key&Description\\
\hline
\texttt{"fg"}&The foreground color, as a list with red, green, blue components\\
\texttt{"bg"}&The background color, as a list with red, green, blue components\\
\texttt{"bold"}&A boolean\\
\texttt{"italics"}&A boolean\\
\texttt{"underline"}&A boolean\\
\texttt{"size"}&An integer\\
\texttt{"file"}&If set, a hyperlink to that file is output\\
\texttt{"word"}&If set, a hyperlink to that word is output\\
\texttt{"vocab"}&Must be set of \texttt{"word"} is set
\end{tabular}

Hyperlinks to files and words point to the file and browser responders, respectively. These responders must be enabled for such links to function.

\section{Alien interface}

Factor's alien inteface provides a means of directly calling native libraries written in C and other languages. There are no
wrappers to write, other than having to specify the return type and parameter types for
the functions you wish to call.

\subsection{Loading native libraries}

A native library must be made available to Factor under a logical name before use. This is done via command line parameters, or the \verb|add-library| word.

The following two command line parameters can be specified for each library to load; the second parameter is optional.
\begin{description}
\item[\texttt{-libraries:\emph{logical}:name=\emph{name}}] associates a logical name with a system-specific native library name,
\item[\texttt{-libraries:\emph{logical}:abi=\emph{type}}] specifies the calling convention to use; \verb|type| is either \verb|cdecl| or \verb|stdcall|. If not specified, the default is \verb|cdecl|. On Unix, all libraries follow the \verb|cdecl| convention. On Windows, most libraries (but not all) follow \verb|stdcall|.
\end{description}

For example:
\begin{alltt}
\textbf{\$} ./f factor.image -libraries:sdl:name=libSDL-1.2.so
\end{alltt}

Another option is to add libraries while Factor is running.
\wordtable{
\vocabulary{alien}
\ordinaryword{add-library}{add-library ( library name abi -- )}
}
Adds a logical library named \verb|library|. The underlying shared library name is \verb|name|, and the calling convention is \verb|abi| and must be either \verb|"cdecl"| or \verb|"stdcall"|.

For example:
\begin{alltt}
\textbf{ok} "kernel32" "kernel32.dll"  "stdcall"  add-library
\end{alltt}
The next word is used in the implementation of the alien interface, and it can also be used
interactively to test if a library can be loaded.

\wordtable{
\vocabulary{alien}
\ordinaryword{load-library}{load-library ( library -- dll )}
}
Attempts to load the library with the given logical name, and outputs a DLL handle. If the library is already loaded, the existing DLL is output.
More will be said about DLL handles in \ref{alien-internals}.

\subsection{Calling native functions}

Native functions are called with the \verb|alien-invoke| word. This word can only be used
from compiled definitions (\ref{compiler}). Executing it inside an interpreted quotation will throw an exception.

\wordtable{
\vocabulary{alien}
\ordinaryword{alien-invoke}{alien-invoke ( return lib func parameters -- )}
}
Invokes the function named \verb|func| in the library with logical name \verb|lib|.

The \verb|return| value is a string naming a C type, and maybe set to \verb|void|, in the case of the native function not returning a value.

The \verb|parameters| value is a list
of strings naming C types. C types are listed in table \ref{c-types}.

For example, suppose you have a \verb|foo| library exporting the following function:
\begin{verbatim}
void the_answer(char* question, int value) {
    printf("The answer to %s is %d.\n",question,value);
}
\end{verbatim}
You can define a word for invoking it:
\begin{verbatim}
: the-answer ( question value -- answer )
    "void" "foo" "the_answer" [ "char*" "int" ]
    alien-invoke ;
\end{verbatim}
Now, after being compiled, the word can be executed with two parameters on the stack:
\begin{alltt}
\textbf{ok} \bs the-answer compile
\textbf{Compiling the-answer}
\textbf{ok} "the question" 42 the-answer
\textbf{The answer to the question is 42.}
\end{alltt}

\subsection{\label{aliens}Alien objects}

\glossary{
name=alien,
description={an instance of the \verb|alien| class, holding a pointer to native memory outside the Factor heap}}
The alien interface can work with an assortment of native data types:
\begin{itemize}
\item integer and floating point values
\item null-terminated strings
\item structures (\ref{alien-structs})
\item unions (\ref{alien-unions})
\end{itemize}
Table \ref{c-types} lists the built-in return value and parameter types. The sizes are given for a 32-bit system. Native numbers and strings are handled in a straight-forward way. Pointers are a bit more complicated, and are wrapped inside alien objects on the Factor side.

\begin{table}
\caption{\label{c-types}Supported native types}
\begin{tabular}{l|l|l}
Name&Size&Representation\\
\hline
\texttt{char}        &1&   Signed integer\\
\texttt{uchar}       &1&   Unsigned integer\\
\texttt{short}       &2&   Signed integer\\
\texttt{ushort}      &2&   Unsigned integer\\
\texttt{int}         &4&   Signed integer\\
\texttt{uint}        &4&   Unsigned integer\\
\texttt{long}        &4&   Signed integer\\
\texttt{ulong}       &4&   Unsigned integer\\
\texttt{longlong}    &8&   Signed integer\\
\texttt{ulonglong}   &8&   Unsigned integer\\
\texttt{float}       &4&   Single-precision float\\
\texttt{double}      &8&   Double-precision float\\
\texttt{char*}       &4&   Pointer to null-terminated byte string\\
\texttt{ushort*}     &4&   Pointer to null-terminated UTF16 string\\
\texttt{void*}       &4&   Generic pointer
\end{tabular}
\end{table}

\wordtable{
\vocabulary{alien}
\ordinaryword{c-size}{c-size ( type -- n )}
}
Outputs the size of the given C type. This is just like the \verb|sizeof| operator in C.
Many native functions expect you to specify sizes for input and output parameters, and
this word can be used for that purpose.

\wordtable{
\vocabulary{alien}
\classword{alien}
}
Pointers to native memory, including \verb|void*| and other types, are represented as objects of the \verb|alien| class.

\wordtable{
\vocabulary{alien}
\predword{alien?}
}
Tests if the object at the top of the stack is an alien pointer.

\subsubsection{\label{alien-structs}Structures}

One way to think of a C-style \verb|struct| is that it abstracts reading and writing field values stored at a range of memory given a pointer, by associating a type and offset with each field. This is the view taken by the alien interface, where defining a C structure creates a set of words for reading and writing fields of various types, offset from a base pointer given by an alien object.

\wordtable{
\vocabulary{alien}
\parsingword{BEGIN-STRUCT:}{BEGIN-STRUCT: \emph{name}}
}
Begins reading a C structure definition.
\wordtable{
\vocabulary{alien}
\parsingword{FIELD:}{FIELD: \emph{type} \emph{name}}
}
Adds a field to the structure. The \verb|type| token identifies a C type, and \verb|name| gives a name to the field. A pair of words is defined, where \verb|structure| and \verb|field| are names, respectively:
\begin{alltt}
\emph{structure}-\emph{field} ( alien -- value )
set-\emph{structure}-\emph{field} ( value alien -- )
\end{alltt}

\wordtable{
\vocabulary{alien}
\parsingword{END-STRUCT}{END-STRUCT}
}
Ends a structure definition.

Defining a structure adds two new C types, where \verb|name| is the name of the structure:
\begin{description}
\item[\texttt{\emph{name}}] the type of the structure itself; structure and union definitions can define members to be of this type.
\item[\texttt{\emph{name}*}] the type of a pointer to the structure; this type can be used with return values and parameters, and in fact it is an alias for \texttt{void*}.
\end{description}
Additionally, the following two words are defined:
\begin{description}
\item[\texttt{<\emph{name}> ( -- byte-array )}] allocates a byte array large enough to hold the structure in the Factor heap. The field accessor words can then be used to work with this byte array. This feature allows calling native functions that expect pointers to caller-allocated structures\footnote{
There is an important restriction, however; the function must not retain the pointer in a global variable after it returns. Since the structure is allocated in the Factor heap, the garbage collector is free to move it between native function calls. If this behavior is undesirable, memory can be managed manually instead (\ref{malloc}).}.
\item[\texttt{\emph{name}-nth ( n alien -- alien )}] given a pointer and index into an array of structures, returns a pointer to the structure at that index.
\end{description}

Here is an example of a structure with various fields:
\begin{verbatim}
BEGIN-STRUCT: surface
    FIELD: uint    flags
    FIELD: format* format
    FIELD: int     w
    FIELD: int     h
    FIELD: ushort  pitch
    FIELD: void*   pixels
    FIELD: int     offset
    FIELD: void*   hwdata
    FIELD: short   clip-x
    FIELD: short   clip-y
    FIELD: ushort   clip-w
    FIELD: ushort   clip-h
    FIELD: uint    unused1
    FIELD: uint    locked
    FIELD: int     map
    FIELD: uint    format_version
    FIELD: int     refcount
END-STRUCT
\end{verbatim}

\subsubsection{\label{alien-unions}Unions}

A C-style \verb|union| type allocates enough space for its largest member. In the alien interface, unions are used to allocate byte arrays in the Factor heap that may hold any one of the union's members.

\wordtable{
\vocabulary{alien}
\parsingword{BEGIN-STRUCT:}{BEGIN-STRUCT: \emph{name}}
}
Begins reading a C union definition.

\wordtable{
\vocabulary{alien}
\parsingword{MEMBER:}{MEMBER: \emph{type}}
}
Adds a member type to the union.

\wordtable{
\vocabulary{alien}
\parsingword{END-UNION}{END-UNION}
}
Ends a union definition.

Unions define C types and words analogous to those for structures; see \ref{alien-structs}.

Here is an example:
\begin{verbatim}
BEGIN-UNION: event
    MEMBER: event
    MEMBER: active-event
    MEMBER: keyboard-event
    MEMBER: motion-event
    MEMBER: button-event
END-UNION
\end{verbatim}

\subsection{\label{alien-internals}Low-level interface}

The alien interface is built on top of a handful of primitives. Sometimes, it is
useful to call these primitives directly for debugging purposes.

\wordtable{
\vocabulary{alien}
\classword{dll}
}
Instances of this class are handles to native libraries.
\wordtable{
\vocabulary{alien}
\ordinaryword{dlopen}{dlopen ( path -- dll )}
}
Opens the specified native library and returns a DLL object. The input parameter is the
name of a native library file,
\emph{not} a logical library name.
\wordtable{
\vocabulary{alien}
\ordinaryword{dlsym}{dlsym ( symbol dll -- address )}
}
Looks up a named symbol in a native library, and outputs it address. If the \verb|dll| is \verb|f|, the lookup is performed in the runtime executable itself.
\wordtable{
\vocabulary{alien}
\ordinaryword{dlclose}{dlclose ( dll -- )}
}
Closes a native library and frees associated native resources.

\wordtable{
\vocabulary{alien}
\ordinaryword{alien-address}{alien-address ( alien -- address )}
}
Outputs the address of an alien, as an integer.

\wordtable{
\vocabulary{alien}
\ordinaryword{<alien>}{<alien> ( address -- alien )}
}
Creates an alien pointing to the specified address.

\wordtable{
\vocabulary{alien}
\ordinaryword{<displaced-alien>}{<displaced-alien> ( offset alien -- alien )}
}
Outputs an alien pointing at an offset from the base pointer of the input alien. Displaced aliens are used to access nested structures and native arrays.

\wordtable{
\vocabulary{alien}
\ordinaryword{alien-signed-cell}{alien-signed-cell ( alien offset -- n )}
\ordinaryword{set-alien-signed-cell}{set-alien-signed-cell ( n alien offset -- )}
\ordinaryword{alien-unsigned-cell}{alien-unsigned-cell ( alien offset -- n )}
\ordinaryword{set-alien-unsigned-cell}{set-alien-unsigned-cell( n alien offset -- )}
\ordinaryword{alien-signed-8}{alien-signed-8 ( alien offset -- n )}
\ordinaryword{set-alien-signed-8}{set-alien-signed-8 ( n alien offset -- )}
\ordinaryword{alien-unsigned-8}{alien-unsigned-8 ( alien offset -- n )}
\ordinaryword{set-alien-unsigned-8}{set-alien-unsigned-8 ( n alien offset -- )}
\ordinaryword{alien-signed-4}{alien-signed-4 ( alien offset -- n )}
\ordinaryword{set-alien-signed-4}{set-alien-signed-4 ( n alien offset -- )}
\ordinaryword{alien-unsigned-4}{alien-unsigned-4 ( alien offset -- n )}
\ordinaryword{set-alien-unsigned-4}{set-alien-unsigned-4 ( n alien offset -- )}
\ordinaryword{alien-signed-2}{alien-signed-2 ( alien offset -- n )}
\ordinaryword{set-alien-signed-2}{set-alien-signed-2 ( n alien offset -- )}
\ordinaryword{alien-unsigned-2}{alien-unsigned-2 ( alien offset -- n )}
\ordinaryword{set-alien-unsigned-2}{set-alien-unsigned-2 ( n alien offset -- )}
\ordinaryword{alien-signed-1}{alien-signed-1 ( alien offset -- n )}
\ordinaryword{set-alien-signed-1}{set-alien-signed-1 ( n alien offset -- )}
\ordinaryword{alien-unsigned-1}{alien-unsigned-1 ( alien offset -- n )}
\ordinaryword{set-alien-unsigned-1}{set-alien-unsigned-1 ( n alien offset -- )}
\ordinaryword{alien-value-string}{alien-value-string ( alien offset -- string )}
}
These primitives read and write native memory. They can be given an alien, displaced alien, or byte array. No bounds checking of any kind is performed.

\subsection{\label{malloc}Manual memory management}

If for whatever reason Factor's memory management is unsuitable for a certain task, you can
directly call the standard C memory management routines. These words are very raw and deal with addresses directly, and of course it is easy to corrupt memory or crash the runtime
this way.
\wordtable{
\vocabulary{kernel-internals}
\ordinaryword{malloc}{malloc ( size -- address )}
}
Allocate a block of size \verb|size| and output a pointer to it.
\wordtable{
\vocabulary{kernel-internals}
\ordinaryword{realloc}{realloc ( address size -- address )}
}
Resize a block previously allocated with \verb|malloc|.
\wordtable{
\vocabulary{kernel-internals}
\ordinaryword{free}{free ( address -- )}
}
Deallocate a block previously allocated with \verb|malloc|.

\chapter{Development tools}

Factor supports interactive development in a live environment. Instead of working with
static executable files and restarting your application after each change, you can
incrementally make changes to your application and test them immediately. If you
notice an undesirable behavior, Factor's powerful reflection features will aid in
pinpointing the error.

If you are used to a statically typed language, you might find Factor's tendency to only fail at runtime hard to work with at first. However, the interactive development tools outlined in this chapter allow a much quicker turn-around time for testing changes. Also, write unit tests -- unit testing is a great way to ensure that old bugs do not re-appear once they've been fixed.

\section{System organization}

\subsection{\label{listener}The listener}

Factor is an \emph{image-based environment}. When you compiled Factor, you also generated a file named \texttt{factor.image}. I will have more to say about images later, but for now it suffices to understand that to start Factor, you must pass the image file name on the command line:
\begin{alltt}
./f factor.image
\textbf{Loading factor.image... relocating... done
Factor 0.73 :: http://factor.sourceforge.net :: unix/x86
(C) 2003, 2005 Slava Pestov, Chris Double,
Mackenzie Straight
ok}
\end{alltt}
An \texttt{\textbf{ok}} prompt is printed after the initial banner, indicating the listener is ready to execute Factor phrases. The listener is a piece of Factor code, like any other; however, it helps to think of it as the primary interface to the Factor system. The listener reads Factor code and executes it. You can try the classical first program:

\begin{alltt}
\textbf{ok} "Hello, world." print
\textbf{Hello, world.}
\end{alltt}


Multi-line phrases are supported; if there are unclosed brackets, the listener outputs \texttt{...} instead of the \texttt{ok} prompt, and the entire phrase is executed once all brackets are closed:

\begin{alltt}
\textbf{ok} [ 1 2 3 ] [
\textbf{...} .
\textbf{...} ] each
\textbf{1
2
3}
\end{alltt}

The listener knows when to print a continuation prompt by looking at the height of the
stack. Parsing words such as \texttt{[} and \texttt{:} leave elements on the parser
stack; these elements are popped by \texttt{]} and \texttt{;}.

On startup, Factor reads the \texttt{.factor-rc} file from your home directory. You can put
any quick definitions you want available at the listener there. To avoid loading this
file, pass the \texttt{-no-user-init} command line switch. Another way to have a set of definitions available at all times is to save a custom image, as described in the next section.

\subsection{Source files}

While it is possible to do all development in the listener and save your work in images, it is far more convenient to work with source files, at least until an in-image structure editor is developed.

By convention, Factor source files are saved with the \texttt{.factor} filename extension. They can be loaded into the image as follows:

\begin{alltt}
\textbf{ok} "examples/numbers-game.factor" run-file
\end{alltt}

In Factor, loading a source file replaces any existing definitions\footnote{But see \ref{compiler} for this is not true of compiled code.}. Each word definition remembers what source file it was loaded from (if any). To reload the source file associated with a definition, use the \texttt{reload} word:

\begin{alltt}
\textbf{ok} \bs draw reload
\end{alltt}

Word definitions also retain the line number where they are located in their original source file. This allows you to open a word definition in jEdit\footnote{\texttt{http://www.jedit.org}} for editing using the
\texttt{jedit} word:

\begin{alltt}
\textbf{ok} \bs compile jedit
\end{alltt}

This word requires that a jEdit instance is already running.

The \texttt{jedit} word will open word definitions from the Factor library once the full path of the Factor source tree is entered into the \texttt{"resource-path"} variable. One way to do this is to add a phrase like the following to your \texttt{.factor-rc}:

\begin{verbatim}
"/home/slava/Factor/" "resource-path" set
\end{verbatim}

\subsection{Images}

The \texttt{factor.image} file is basically a dump of all objects in the heap. A new image can be saved as follows:

\begin{alltt}
\textbf{ok} "work.image" save-image
\textbf{Saving work.image...}
\end{alltt}

When you save an image before exiting Factor, then start Factor again, everything will be almost as you left it. Try the following:

\begin{alltt}
./f factor.image
\textbf{ok} "Learn Factor" "reminder" set
\textbf{ok} "factor.image" save-image bye
\textbf{Saving factor.image...}
\end{alltt}

Factor will save the image and exit. Now start it again and see that the reminder is still there:

\begin{alltt}
./f factor.image
\textbf{ok} "reminder" get .
\textbf{"Learn Factor"}
\end{alltt}

This is what is meant by the image being an \emph{infinite session}. When you shut down and restart Factor, what happends is much closer to a Laptop's ``suspend'' mode, than a desktop computer being fully shut down.

\subsection{Looking at objects}

Probably the most important debugging tool of them all is the \texttt{.} word. It prints the object at the top of the stack in a form that can be parsed by the Factor parser. A related word is \texttt{prettyprint}. It is identical to \texttt{.} except the output is more verbose; lists, vectors and hashtables are broken up into multiple lines and indented.

\begin{alltt}
\textbf{ok} [ [ \tto 1 \ttc \tto 2 \ttc ] dup car swap cdr ] .
[ [ \tto 1 \ttc \tto 2 \ttc ] dup car swap cdr ]
\end{alltt}

Most objects print in a parsable form, but not all. One exceptions to this rule is objects with external state, such as I/O ports or aliens (pointers to native structures). Also, objects with circular or very deeply nested structure will not print in a fully parsable form, since the prettyprinter has a limit on maximum nesting. Here is an example -- a vector is created, that holds a list whose first element is the vector itself:

\begin{alltt}
\textbf{ok} \tto \ttc [ unit 0 ] keep [ set-vector-nth ] keep .
\tto [ ... ] \ttc
\end{alltt}

The prettyprinted form of a vector or list with many elements is not always readable. The \texttt{[.]} and \texttt{\tto.\ttc} words output a list or a vector, respectively, with each element on its own line. In fact, the stack printing words are defined in terms of \texttt{[.]} and \texttt{\tto.\ttc}:

\begin{verbatim}
: .s datastack  {.} ;
: .r callstack  {.} ;
: .n namestack  [.] ;
: .c catchstack [.] ;
\end{verbatim}

Before we move on, one final set of output words comes is used to output integers in
different numeric bases. The \texttt{.b} word prints an integer in binary, \texttt{.o} in octal, and \texttt{.h} in hexadecimal.

\begin{alltt}
\textbf{ok} 31337 .b
\textbf{111101001101001}
\textbf{ok} 31337 .o
\textbf{75151}
\textbf{ok} 31337 .h
\textbf{7a69}
\end{alltt}

\section{Word tools}

\subsection{Exploring vocabularies}

Factor organizes code in a two-tier structure of vocabularies and words. A word is the smallest unit of code; it corresponds to a function or method in other languages. Vocabularies group related words together for easy browsing and tracking of source dependencies.

Entering \texttt{vocabs .}~in the listener produces a list of all existing vocabularies:

\begin{alltt}
\textbf{ok} vocabs .
\textbf{[ "alien" "ansi" "assembler" "browser-responder"
"command-line" "compiler" "cont-responder" "errors"
"file-responder" "files" "gadgets" "generic"
"hashtables" "html" "httpd" "httpd-responder" "image"
"inference" "interpreter" "io-internals" "jedit"
"kernel" "kernel-internals" "line-editor" "listener"
"lists" "logging" "math" "math-internals" "memory"
"namespaces" "parser" "prettyprint" "profiler"
"quit-responder" "random" "resource-responder"
"scratchpad" "sdl" "shells" "stdio" "streams"
"strings" "syntax" "telnetd" "test" "test-responder"
"threads" "unparser" "url-encoding" "vectors" "words" ]}
\end{alltt}

As you can see, there are a lot of vocabularies! Now, you can use \texttt{words .}~to list the words inside a given vocabulary:

\begin{alltt}
\textbf{ok} "namespaces" words .
\textbf{[ (get) , <namespace> >n append, bind change cons@
dec extend get global inc init-namespaces list-buffer
literal, make-list make-rlist make-rstring make-string
make-vector n> namespace namestack nest off on put set
set-global set-namestack unique, unique@ with-scope ]}
\end{alltt}

You can look at the definition of any word, including library words, using \texttt{see}. Keep in mind you might have to \texttt{USE:} the vocabulary first.

\begin{alltt}
\textbf{ok} USE: httpd
\textbf{ok} \bs httpd-connection see
\textbf{IN: httpd : httpd-connection ( socket -- )
    "http-server" get accept [
        httpd-client
    ] in-thread drop ;}
\end{alltt}

The \texttt{see} word shows a reconstruction of the source code, not the original source code. So in particular, formatting and some comments are lost.

\subsection{Cross-referencing words}

The \texttt{apropos.} word is handy when searching for related words. It lists all words
whose names contain a given string. The \texttt{apropos.} word is also useful when you know the exact name of a word, but are unsure what vocabulary it is in. For example, if you're looking for ways to iterate over various collections, you can do an apropos search for \texttt{map}:

\begin{alltt}
\textbf{ok} "map" apropos.
\textbf{IN: inference
type-value-map
IN: lists
map
map-with
IN: sdl
set-surface-map
surface-map
IN: strings
string-map
IN: vectors
vector-map}
\end{alltt}

From the above output, you can see that \texttt{map} is for lists, \texttt{string-map} is for strings, and \texttt{vector-map} is for vectors.

The \texttt{usage} word finds all words that refer to a given word and pushes a list on the stack. This word is helpful in two situations; the first is for learning -- a good way to learn a word is to see it used in context. The second is during refactoring -- if you change a word's stack effect, you must also update all words that call it. Usually you print the
return value of \texttt{usage} using \texttt{.}:

\begin{alltt}
\textbf{ok} \bs string-map usage .
\textbf{schars>entities
filter-null
url-encode}
\end{alltt}

Another useful word is \texttt{usages}. Unlike \texttt{usage}, it finds all usages, even
indirect ones -- so if a word refers to another word that refers to the given word,
both words will be in the output list.

\subsection{Exploring classes}

Factor supports object-oriented programming via generic words. Generic words are called
like ordinary words, however they can have multiple definitions, one per class, and
these definitions do not have to appear in the same source file. Such a definition is
termed a \emph{method}, and the method is said to \emph{specialize} on a certain
class. A class in the most
general sense is just a set of objects. You can output a list of classes in the system
with \texttt{classes .}:

\begin{alltt}
\textbf{ok} classes.
\textbf{[ alien alien-error byte-array displaced-alien
dll ansi-stream disp-only displaced indirect operand
register absolute absolute-16/16 relative relative-bitfld
item kernel-error no-method border checkbox dialog editor
ellipse etched-rect frame gadget hand hollow-ellipse
hollow-rect label line menu pane pile plain-ellipse
plain-rect rectangle roll-rect scroller shelf slider
stack tile viewport world 2generic arrayed builtin
complement generic null object predicate tuple
tuple-class union hashtable html-stream class-tie
computed inference-error inference-warning literal
literal-tie value buffer port jedit-stream boolean
general-t array cons general-list list bignum complex
fixnum float integer number ratio rational real
parse-error potential-float potential-ratio
button-down-event button-up-event joy-axis-event
joy-ball-event joy-button-down-event joy-button-up-event
joy-hat-event key-down-event key-up-event motion-event
quit-event resize-event user-event sequence stdio-stream
client-stream fd-stream null-stream server string-output
wrapper-stream LETTER blank digit letter printable sbuf
string text POSTPONE: f POSTPONE: t vector compound
primitive symbol undefined word ]}
\end{alltt}

If you \texttt{see} a generic word, all methods defined on the generic word are shown.
Alternatively, you can use \texttt{methods.} to print all methods specializing on a
given class:

\begin{alltt}
\textbf{ok} \bs list methods.
\textbf{PREDICATE: general-list list
    dup [
        last* cdr
    ] when not ;
IN: gadgets
M: list custom-sheet
    [
        length count
    ] keep zip alist>sheet "Elements:" <titled> ;
IN: prettyprint
M: list prettyprint*
    [
        [
            POSTPONE: [
        ] car swap [
            POSTPONE: ]
        ] car prettyprint-sequence
    ] check-recursion ;}
\end{alltt}

\subsection{Browsing via the HTTP server}


A more sophisticated way to browse the library is using the integrated HTTP server. You can start the HTTP server using the following pair of commands:

\begin{alltt}
\textbf{ok} USE: httpd
\textbf{ok} USE: threads
\textbf{ok} [ 8888 httpd ] in-thread
\end{alltt}

Then, point your browser to the following URL, and start browsing:

\begin{quote}
\texttt{http://localhost:8888/responder/inspect/vocabularies}
\end{quote}

To stop the HTTP server, evaluate the \verb|stop-httpd| word.

\section{Dealing with runtime errors}

\subsection{Looking at stacks}

To see the contents of the data stack, use the \texttt{.s} word. Similarly, the other stacks can be shown with \texttt{.r} (return stack), \texttt{.n} (name stack), and \texttt{.c} (catch stack). Each stack is printed with each element on its own line; the top of the stack is the first element printed.

\subsection{The debugger}

If the execution of a phrase in the listener causes an error to be thrown, the error
is printed and the stacks at the time of the error are saved. If you're spent any
time with Factor at all, you are probably familiar with this type of message:

\begin{alltt}
\textbf{ok} [ 1 2 3 ] 4 append reverse
\textbf{The generic word car does not have a suitable method for 4
:s :r :n :c show stacks at time of error.
:get ( var -- value ) inspects the error namestack.}
\end{alltt}

The words \texttt{:s}, \texttt{:r}, \texttt{:n} and \texttt{:s} behave like their counterparts that are prefixed with \texttt{.}, except they show the stacks as they were when the error was thrown.

The return stack warrants some special attention. To successfully develop Factor, you will need to learn to understand how it works. Lets look at the first few lines of the return stack at the time of the above error:

\begin{verbatim}
[ swap cdr ]
uncons
[ r> tuck 2slip ]
(each)
[ swons ]
[ each ]
each
\end{verbatim}

You can see the sequence of calls leading up to the error was \texttt{each} calling \texttt{(each)} calling \texttt{uncons}. The error tells us that the \texttt{car} word is the one that failed. Now, you can stare at the stack dump, at notice that if the call to \texttt{car} was successful and execution returned to \texttt{(each)}, the quotation \texttt{[ r> tuck 2slip ]} would resume executing. The first word there, \texttt{r>}, would take the quotation \texttt{[ swons ]} and put it back on the data stack. After \texttt{(each)} returned, it would then continue executing the quotation \texttt{[ each ]}. So what is going on here is a recursive loop, \texttt{[ swons ] each}. If you look at the definition of \texttt{reverse}, you will see that this is exactly what is being done:

\begin{verbatim}
: reverse ( list -- list ) [ ] swap [ swons ] each ;
\end{verbatim}

So a list is being reversed, but at some stage, the \texttt{car} is taken of something that is not a number. Now, you can look at the data stack with \texttt{:s}:

\begin{verbatim}
<< no-method [ ] 4 car >>
car
4
4
[ 3 2 1 ]
\end{verbatim}

So now, the mystery has been solved: as \texttt{reverse} iterates down the input value, it hits a cons cells whose \texttt{cdr} is not a list. Indeed, if you look at the value we are passing to \texttt{reverse}, you will see why:

\begin{alltt}
\textbf{ok} [ 1 2 3 ] 4 append .
[[ 1 [[ 2 [[ 3 4 ]] ]] ]]
\end{alltt}

In the future, the debugger will be linked with the walker, documented below. Right now, the walker is a separate tool. Another caveat is that in compiled code, the return stack is not reconstructed if there is an error. Until this is fixed, you should only compile code once it is debugged. For more potential compiler pitfalls, see \ref{compiler}.

\subsection{The walker}

The walker lets you step through the execution of a qotation. When a compound definition is reached, you can either keep walking inside the definition, or execute it in one step. The stacks can be inspected at each stage.

There are two ways to use the walker. First of all, you can call the \texttt{walk} word explicitly, giving it a quotation:

\begin{alltt}
\textbf{ok} [ [ 10 [ dup , ] repeat ] make-list ] walk
\textbf{\&s \&r \&n \&c show stepper stacks.
\&get ( var -- value ) inspects the stepper namestack.
step -- single step over
into -- single step into
continue -- continue execution
bye -- exit single-stepper
[ [ 10 [ dup , ] repeat ] make-list ]
walk}
\end{alltt}

As you can see, the walker prints a brief help message, then the currently executing quotation. It changes the listener prompt from \texttt{ok} to \texttt{walk}, to remind you that there is a suspended continuation.

The first element of the quotation shown is the next object to be evaluated. If it is a literal, both \texttt{step} and \texttt{into} have the effect of pushing it on the walker data stack. If it is a compound definition, then \texttt{into} will recurse the walker into the compound definition; otherwise, the word executes in one step.

The \texttt{\&r} word shows the walker return stack, which is laid out just like the primary interpreter's return stack. In fact, a good way to understand how Factor's return stack works is to play with the walker.

Note that the walker does not automatically stop when the quotation originally given finishes executing; it just keeps on walking up the return stack, and even lets you step through the listener's code. You can invoke \texttt{continue} or \texttt{exit} to terminate the walker.

While the walker can be invoked explicitly using the \texttt{walk} word, sometimes it is more convenient to \emph{annotate} a word such that the walker is invoked automatically when the word is called. This can be done using the \texttt{break} word:

\begin{alltt}
\textbf{ok} \bs layout* break
\end{alltt}

Now, when some piece of code calls \texttt{layout*}, the walker will open, and you will be able to step through execution and see exactly what's going on. An important point to keep in mind is that when the walker is invoked in this manner, \texttt{exit} will not have the desired effect; execution will continue, but the data stack will be inconsistent, and an error will most likely be raised a short time later. Always use \texttt{continue} to resume execution after a break.

The walker is very handy, but sometimes you just want to see if a word is being called at all and when, and you don't care to single-step it. In that case, you can use the \texttt{watch} word:

\begin{alltt}
\textbf{ok} \bs draw-shape break
\end{alltt}

Now when \texttt{draw-shape} is called, a message will be printed to that effect.

You can undo the effect of \texttt{break} or \texttt{watch} by reloading the original source file containing the word definition in question:

\begin{alltt}
\textbf{ok} \bs layout* reload
\textbf{ok} \bs draw-shape reload
\end{alltt}

\subsection{Dealing with hangs}

If you accidentally start an infinite loop, you can send the Factor runtime a \texttt{QUIT} signal. On Unix, this is done by pressing \texttt{Control-\bs} in the controlling terminal. This will cause the runtime to dump the data and return stacks in a semi-readable form. Note that this will help you find the root cause of the hang, but it will not let you interrupt the infinite loop.


\section{Defensive coding}

\subsection{Unit testing}

Unit tests are very easy to write. They are usually placed in source files. A unit test can be executed with the \texttt{unit-test} word in the \texttt{test} vocabulary. This word takes a list and a quotation; the quotation is executed, and the resulting data stack is compared against the list. If they do not equal, the unit test has failed. Here is an example of a unit test:

\begin{verbatim}
[ "Hello, crazy world" ] [
    "editor" get [ 0 caret set ] bind
    ", crazy" 5 "editor" get [ line-insert ] bind
    "editor" get [ line-text get ] bind
] unit-test
\end{verbatim}

To have a unit test assert that a piece of code does not execute successfully, but rather throws an exception, use the \texttt{unit-test-fails} word. It takes only one quotation; if the quotation does \emph{not} throw an exception, the unit test has failed.

\begin{verbatim}
[ -3 { } vector-nth ] unit-test-fails
\end{verbatim}

Unit testing is a good habit to get into. Sometimes, writing tests first, before any code, can speed the development process too; by running your unit test script, you can gauge progress.

\subsection{Stack effect inference}

While most programming errors in Factor are only caught at runtime, the stack effect checker can be useful for checking correctness of code before it is run. It can also help narrow down problems with stack shuffling. The stack checker is used by passing a quotation to the \texttt{infer} word. It uses a sophisticated algorithm to infer stack effects of recursive words, combinators, and other tricky constructions, however, it cannot infer the stack effect of all words. In particular, anything using continuations, such as \texttt{catch} and I/O, will stump the stack checker. Despite this fault, it is still a useful tool.

\begin{alltt}
\textbf{ok} [ pile-fill * >fixnum over pref-size dup y
\texttt{...} [ + ] change ] infer .
\textbf{[ [ tuple number tuple ] [ tuple fixnum object number ] ]}
\end{alltt}

The stack checker will report an error it it cannot infer the stack effect of a quotation. The ``recursive state'' dump is similar to a return stack, but it is not a real return stack, since only a code walk is taking place, not full evaluation. Understanding recursive state dumps is an art, much like understanding return stacks.

\begin{alltt}
\textbf{ok} [ 100 [ f f cons ] repeat ] infer .
\textbf{! Inference error: Unbalanced branches
! Recursive state:
! [ (repeat) G:54044 pick pick >= [ 3drop ]
    [ [ swap >r call 1 + r> ] keep (repeat) ] ifte ]
! [ repeat G:54042 0 -rot (repeat) ]
:s :r :n :c show stacks at time of error.
:get ( var -- value ) inspects the error namestack.}
\end{alltt}

One reason stack inference might fail is if the quotation contains unbalanced branches, as above. For the inference to work, both branches of a conditional must exit with the same stack height.

Another situation when it fails is if your code calls quotations that are not statically known. This can happen if the word in question uses continuations, or if it pulls a quotation from a variable and calls it. This can also happen if you wrote your own combinator, but forgot to mark it as \texttt{inline}. For example, the following will fail:

\begin{alltt}
\textbf{ok} : dip swap >r call r> ;
\textbf{ok} [ [ + ] dip * ] infer .
! Inference error: A literal value was expected where a
computed value was found: \#<computed @ 679711507>
...
\end{alltt}

However, defining \texttt{dip} to be inlined will work:

\begin{alltt}
\textbf{ok} : dip swap >r call r> ; inline
\textbf{ok} [ [ + ] dip * ] infer .
\textbf{[ [ number number number ] [ number ] ]}
\end{alltt}

You can combine unit testing with stack effect inference by writing unit tests that check stack effects of words. In fact, this can be automated with the \texttt{infer>test.} word; it takes a quotation on the stack, and prints a code snippet that tests the stack effect of the quotation:

\begin{alltt}
\textbf{ok} [ draw-shape ] infer>test.
\textbf{[ [ [ object ] [  ] ] ]
[ [ draw-shape ] infer ]
unit-test}
\end{alltt}

You can then copy and paste this snippet into a test script, and run the test script after
making changes to the word to ensure its stack effect signature has not changed.

\section{Optimization}

While both the Factor interpreter and compiler are relatively slow at this stage, there
are still ways you can make your Factor code go faster. The key is to find bottlenecks,
and optimize them.

\subsection{Timing code}

The \texttt{time} word reports the time taken to execute a quotation, in milliseconds. The portion of time spent in garbage collection is also shown:

\begin{alltt}
\textbf{ok} [ 1000000 [ f f cons drop ] repeat ] time
\textbf{515 milliseconds run time
11 milliseconds GC time}
\end{alltt}

\subsection{Exploring memory usage}

Factor supports heap introspection. You can find all objects in the heap that match a certain predicate using the \texttt{instances} word. For example, if you suspect a resource leak, you can find all I/O ports as follows:

\begin{alltt}
\textbf{ok} USE: io-internals
\textbf{ok} [ port? ] instances .
\textbf{[ \#<port @ 805466443> \#<port @ 805466499> ]}
\end{alltt}

The \texttt{references} word finds all objects that refer to a given object:

\begin{alltt}
\textbf{ok} [ float? ] instances car references .
\textbf{[ \#<array @ 805542171> [ -1.0 0.0 / ] ]}
\end{alltt}

You can print a memory usage summary with \texttt{room.}:

\begin{alltt}
\textbf{ok} room.
\textbf{Data space: 16384 KB total 2530 KB used 13853 KB free
Code space: 16384 KB total 490 KB used 15893 KB free}
\end{alltt}

And finally, a detailed memory allocation breakdown by type with \texttt{heap-stats.}:

\begin{alltt}
\textbf{ok} heap-stats.
\textbf{bignum: 312 bytes, 17 instances
cons: 850376 bytes, 106297 instances
float: 112 bytes, 7 instances
t: 8 bytes, 1 instances
array: 202064 bytes, 3756 instances
hashtable: 54912 bytes, 3432 instances
vector: 5184 bytes, 324 instances
string: 391024 bytes, 7056 instances
sbuf: 64 bytes, 4 instances
port: 112 bytes, 2 instances
word: 96960 bytes, 3030 instances
tuple: 688 bytes, 22 instances}
\end{alltt}

\subsection{The profiler}

Factor provides a statistical sampling profiler for narrowing down memory and processor bottlenecks.
The profiler is only supported on Unix platforms. On FreeBSD 4.x, the Factor runtime must
be compiled without the \texttt{-pthread} switch, since FreeBS 4.x userspace threading makes
use of a signal that conflicts with the signal used for profiling.

The \texttt{allot-profile} word executes a quotation with the memory profiler enabled, then prints a list of all words that allocated memory, along with the bytes allocated. Note that during particularly long executions, or executions where a lot of memory is allocated, these counters may overrun.

\begin{alltt}
\textbf{ok} [ "boot.image.le32" make-image ] allot-profile
\emph{... many lines omitted ...}
\textbf{[[ write-little-endian-32 673952 ]]
[[ wait-to-read-line 788640 ]]
[[ blocking-read-line 821264 ]]
[[ vocabularies 822624 ]]
[[ parse-resource 823376 ]]
[[ next-line 1116440 ]]
[[ vector-map 1326504 ]]
[[ fixup-words 1326520 ]]
[[ vector-each 1768640 ]]
[[ (parse) 2434208 ]]
[[ classes 2517920 ]]
[[ when* 2939088 ]]
[[ while 3614408 ]]
[[ (parse-stream) 3634552 ]]
[[ make-list 3862000 ]]
[[ object 4143784 ]]
[[ each 4712080 ]]
[[ run-resource 5036904 ]]
[[ (callcc) 5183400 ]]
[[ catch 5188976 ]]
[[ 2slip 8631736 ]]
[[ end 202896600 ]]
[[ make-image 208611888 ]]
[[ with-scope 437823992 ]]}
\end{alltt}

The \texttt{call-profile} word executes a quotation with the CPU profiler enabled, then prints a list of all words that were found on the return stack, along with the number of times they were seen there. This gives a rough idea of what words are taking up the majority of execution time.

\begin{alltt}
\textbf{ok} [ "boot.image.le32" make-image ] call-profile
\emph{... many lines omitted ...}
\textbf{[[ stream-write 7 ]]
[[ wait-to-write 7 ]]
[[ vector-map 11 ]]
[[ fixup-words 11 ]]
[[ when* 12 ]]
[[ write 16 ]]
[[ write-word 17 ]]
[[ parse-loop 22 ]]
[[ make-list 24 ]]
[[ (parse) 29 ]]
[[ blocking-write 32 ]]
[[ while 35 ]]
[[ (parse-stream) 36 ]]
[[ dispatch 47 ]]
[[ run-resource 50 ]]
[[ write-little-endian-32 76 ]]
[[ (callcc) 173 ]]
[[ catch 174 ]]
[[ each 175 ]]
[[ 2slip 199 ]]
[[ end 747 ]]
[[ make-image 785 ]]
[[ with-scope 1848 ]]}
\end{alltt}

Normally, the memory and CPU profilers run every millisecond, and increment counters for all words on the return stack. The \texttt{only-top} variable can be switched on, in which case only the counter for the word at the top of the return stack is incremented. This gives a more localized picture of CPU and memory usage.

\subsection{\label{compiler}The compiler}

The compiler can provide a substantial speed boost for words whose stack effect can be inferred. Words without a known stack effect cannot be compiled, and must be run in the interpreter. The compiler generates native code, and so far, x86 and PowerPC backends have been developed.

To compile a single word, call \texttt{compile}:

\begin{alltt}
\textbf{ok} \bs pref-size compile
\textbf{Compiling pref-size}
\end{alltt}

During bootstrap, all words in the library with a known stack effect are compiled. You can
circumvent this, for whatever reason, by passing the \texttt{-no-compile} switch during
bootstrap:

\begin{alltt}
\textbf{bash\$} ./f boot.image.le32 -no-compile
\end{alltt}

The compiler has two limitations you must be aware of. First, if an exception is thrown in compiled code, the return stack will be incomplete, since compiled words do not push themselves there. Second, compiled code cannot be profiled. These limitations will be resolved in a future release.

The compiler consists of multiple stages -- first, a dataflow graph is inferred, then various optimizations are done on this graph, then it is transformed into a linear representation, further optimizations are done, and finally, machine code is generated from the linear representation. To perform everything except for the machine code generation, use the \texttt{precompile} word. This will dump the optimized linear IR instead of generating code, which can be useful sometimes.

\begin{alltt}
\textbf{ok} \bs append precompile
\textbf{[ \#prologue ]
[ over ]
[[ \#jump-t-label G:54091 ]]
[ swap ]
[ drop ]
[ \#return ]
[[ \#label G:54091 ]]
[ >r ]
[[ \#call uncons ]]
[ r> ]
[[ \#call append ]]
[[ \#jump cons ]]}
\end{alltt}

\printglossary

\input{handbook.ind}

\end{document}
