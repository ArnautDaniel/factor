Formal model of a mini-Factor.
------------------------------

* Objects

OBJ is by definition the set of all possible objects.

OBJ contains objects of three distinct types:

- f

- [[ a b ]] where a and b are objects. Abbreviation: [ a b c ... ] for
  nested conses terminating with f.

- primitive words:
  call ?
  cons car cdr
  drop dup swap >r r>
  datastack set-datastack callstack set-callstack

* Arrows

ARROW is by definition the set of recursive (effectively computable)
functions from OBJ to OBJ.

* The e function

Now consider a map e: OBJ * OBJ * OBJ --> OBJ.

The e function takes three objects (or really, a list of three elements,
which is itself an object) and is defined recursively as follows:

(Here, uppercase words are variables, lowercase are symbols.)

** Base case; no more code to evaluate, return resulting datastack:

e[DS f f] = DS

** Recursive cases:

e[DS < Q CS > f] = e[DS CS Q]
e[DS CS < X CF >] = e[< X DS > CS CF]

** Primitive words:

e[< Q DS > CS < call CF >] = e[DS < CF CS > Q]
e[< F < T < f DS > > > CS < ? CF >] = e[< F DS > CS CF]
e[< F < T < X DS > > > CS < ? CF >] = e[< T DS > CS CF]

e[< A D DS > CS < cons CF >] = e[< < A D > DS > CS CF]
e[< < A D > DS > CS < car CF >] = e[< A DS > CS CF]
e[< < A D > DS > CS < cdr CF >] = e[< D DS > CS CF]

e[< X DS > CS < drop CF >] = e[DS CS CF]
e[< X DS > CS < dup CF >] = e[< X < X DS > > CS CF]
e[< X < Y DS > > CS < swap CF >] = e[< Y < X DS > > CS CF]
e[< X DS > CS < >r CF >] = e[DS < X CS > CF]
e[DS < X CS > < r> CF >] = e[< X DS > CS CF]

e[DS CS < datastack CF >] = e[< DS DS > CS CF]
e[< L DS > CS < set-datastack CF >] = e[L CS CF]
e[DS CS < callstack CF >] = e[< CS DS > CS CF]
e[< L DS > CS < set-callstack CF >] = e[DS L CF]

Define

eval Q = e[f,f,Q]

* A fixed-point combinator

[ dup cons over call ] dup cons over call

* Turing-completeness

First, I claim that e is recursive; so e is an element of ARROW.

Furthermore, for any element g in ARROW, there exists an element G in
OBJ such that g(x) = eval < x G >. This means that the language executed
by e is turing-complete, and that ARROW can be identified with a subset
of OBJ.

Furthermore, there exists an element E in OBJ such that
e(x) = eval < x E >; so we have proven that there exists a Factor
interpreter written in Factor.
