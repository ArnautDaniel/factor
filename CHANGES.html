<!-- :noWordSep=+-*\=><;.?/'()%,_|: -->

<html>
<head><title>Factor change log</title></head>
<body>

<h1>Factor 0.79:</h1>

<ul>

<li>The <code>ifte</code> combinator has been renamed to <code>if</code>!</li>

<li>Compiler:

<ul>
<li>New basic block optimizer performs more aggressive dead load and store elimination.</li>
<li>Stack shuffles are compiled more efficiently.</li>
<li>Pushing literals on either side of a stack shuffle is now compiled more efficiently.</li>
</ul>

</li>

<li>User interface:

<ul>

<li>Added expandable outliners. Used by the inspector, <code>.s</code>, <code>usage.</code>, <code>uses.</code>, <code>vocabs.</code>, and various other words.</li>
<li>Added word completion to the listener pane; press <code>TAB</code>.</li>
<li>Added word navigation shortcuts to the listener pane; press <code>C+LEFT</code> and <code>C+RIGHT</code> to move a word at a time, and <code>C+BACKSPACE</code> and <code>C+DELETE</code> to delete the previous and next word, respectively.</li>
<lI>Added mouse-over help for presentations</lI>
</ul>

</li>

<li>Collections:

<ul>
<li>Faster <code>map</code>, <code>2each</code> and <code>2map</code>.</li>
<li>Arrays are now better supported and should be used instead of vectors where resizing is not desired.</li>
<li>Some new sequence words that do not bounds check: <code>nth-unsafe</code> and <code>set-nth-unsafe</code>. These should only be used in special circumstances, such as inner loops (<code>each</code>, <code>map</code> and so on use them).</li>
<li>New <code>replace-slice ( new from to seq -- seq )</code> word replaces a slice of a sequence with another sequence.</li>
<li>Hashtables did not obey the rule that equal objects must have equal hashcodes, so using hashtables as hashtable keys did not work.</li>
<li>New <code>mismatch ( seq seq -- i )</code> word returns first index where two sequences
differ, or -1 if they have equal elements.</li>
<li>New <code>drop-prefix ( seq seq -- seq seq )</code> word returns a pair of
sequences which have the same elements as the two input sequences, with the common
prefix removed.</li>
</li>

<li>Everything else:

<ul>
<li>Quaternions added to math library.

Quaternions are represented as pairs of real numbers. Literal syntax is <code>Q{ a b c d }Q</code>, where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are real numbers.

Many quaternion operations can be done using Factor's existing vector algebra words; this follows from the mathematical fact that the quaternions are a 2-dimensional vector space over the complex numbers:
<ul>
<li>Addition: <code>v+</code></li>
<li>Subtraction: <code>v-</code></li>
<li>Negation: <code>vneg</code></li>
<li>Norm: <code>norm</code></li>
<li>Multiplication by a complex number on the left: <code>n*v</code></li>
</ul>
A few new words are also needed:
<ul>
<li>Convert complex number to quaternion: <code>c&gt;n</code></li>
<li>Multiply by a complex number on the right: <code>q*n</code></li>
<li>Quaternion multiplication: <code>q*</code></li>
<li>Quaternion division: <code>q/</code></li>
<li>Quaternion conjugate: <code>qconjugate</code></li>
</ul>

</li>

<li>Easier exception handling. The <code>cleanup ( try cleanup -- )</code> word encapsulates the following idiom:
<pre>
[ A ] [ B rethrow ] catch
[ A ] [ B ] cleanup
</pre>
The <code>recover ( try recover -- )</code> word encapsulates the following idiom:
<pre>
[ A ] [ [ B ] when* ] catch
[ A ] [ B ] recover
</pre>
The <code>catch ( try -- error/f )</code> word no longer takes a quotation that receives the error caught; rather, it just pushes the error that was caught on the stack. That is, the old way:
<pre>
[ A ] [ B ] catch
</pre>
Becomes:
<pre>
[ A ] catch B
</pre>
However, most uses of <code>catch</code> can be replaced by <code>cleanup</code> and <code>recover</code>.</li>
<li>The distinct <code>t</code> type is gone. Now, the <code>t</code> object is just a symbol.</li>
<li>A new <code>with-server ( port ident quot -- )</code> combinator takes care of listening on a network socket, logging client connections, spawning client handler threads, and error handling. The quotation is called for each client, in a new scope with the client socket as the default stream.</li>
<li>New <code>1+</code>, <code>1-</code> words are a bit faster than <code>1 +</code> and <code>1 -</code> since there is one less generic dispatch involved.</li>
<li>On Windows, FFI errors would raise a signal 11 instead of reporting a nice message.</li>
</ul>

<li>Contributed code:

<ul>

<li>Intel 8080 CPU and Space Invaders emulator in <code>contrib/space-invaders</code> (Chris Double)</li>
<li>AOL Instant Messenger chat client library in <code>contrib/aim</code> (Doug Coleman)</li>
<li>Cairo graphics library binding in <code>contrib/cairo</code> (Sampo Vuori)</li>
</ul>

</li>

</ul>

<h1>Factor 0.78:</h1>

<ul>
<li>Consecutive stack operations are now composed into single shuffle expressions.</li>
<li>The return stack pointer is now stored in a register on x86.</li>
<li>Non-recursive inline words are compiled more efficiently.</li>
<li>Fix PowerPC bootstrap issue, and <code>fixnum-shift</code>, <code>fixnum/i</code> overflow.</li>
</ul>

<h1>Factor 0.77:</h1>

<ul>
<li>Compiler:
<ul>
<li>Optimizing out conditionals where the test value is a constant.</li>
<li>Optimizing out type checks that are always/never satisfied.</li>
<li>Inlining method bodies when generic words are called on values with known compile-time types.</li>
<li>Side-effect-free words that output immutable values are evaluated at compile time if all their inputs are literal. You can declare a word as having this condition by suffixing the definition with <code>foldable</code>, eg:
<pre>: cube dup dup * * ; foldable</pre></li>
<li>Various arithmetic identities such as <code>1 *</code> are optimized out.
</ul>

</li>

<li>Collections:

<ul>
<li><code>sort ( seq quot -- | quot: elt elt -- -1/0/1 )</code> combinator now works with any sequence, not just a list. The comparator also has to return a signed integer, not just a boolean. It is much faster than the old sorting algorithm.</li>
<li><code>binsearch ( elt seq quot -- i | quot: elt elt -- -1/0/1 )</code> and <code>binsearch ( elt seq quot -- elt | quot: elt elt -- -1/0/1 )</code> combinators perform a binary search on a sorted sequence.</li>
<li><code>2each ( seq seq quot -- quot: elt -- elt )</code> combinator</li>
<li><code>join ( seq glue -- seq )</code> word. Takes a sequence of sequences, and constructs a new sequence with the glue in between each sequence. For example:
<pre>  [ "usr" "bin" "grep" ] "/" join
<b>"usr/bin/grep"</b></pre></li>
<li>Integers now support the sequence protocol. An integer is an increasing sequence of its predecessors. This means the <code>count ( n -- [ 0 ... n-1 ] )</code> word is gone; just use <code>&gt;vector</code> instead. Also, <code>project</code> has been made redundant by <code>map</code>.</li>
<li>The <code>seq-transpose ( seq -- seq )</code> word is now named <code>flip</code>.
</li>
<li>The matrices library has been greatly simplified. Matrices are now represented as vectors of vectors, and matrix words have been moved to the <code>math</code> vocabulary.</li>
<li>More descriptive "out of bounds" errors.</li>
<li>New <code>make-hash ( quot -- namespace )</code> combinator executes quotation in a new namespace, which is then pushed on the stack.</li>
<li>The <code>&lt;namespace&gt;</code> word is gone. It would create a hashtable with a default capacity. Now, just write <code>{{ }} clone</code>.</li>
<li>Sequence construction words changed:
<pre>
make-list    ==&gt; [ ] make
make-vector  ==&gt; { } make
make-string  ==&gt; "" make
make-rstring ==&gt; "" make reverse
make-sbuf    ==&gt; SBUF" " make
</pre></li>
<li>The <code>every?</code> word has been replaced with <code>monotonic? ( seq quot -- ? )</code>. Its behavior is a superset of <code>every?</code> -- it now accepts any transitive relation, and checks if the sequence is monotonic under this relation. For example,
<code>[ = ] monotonic?</code> checks if all elements in a sequence are equal, and <code>[ < ] monotonic?</code> checks for a strictly increasing sequence of integers.</li> 
</ul>

</li>

<li>Development tools:

<ul>
<li>In the UI, object slots are now clickable in the inspector.</li>
<li>Inspector now supports a history and an interactive loop; it prints a brief help message when it starts describing usage.</li>
<li>The prettyprinter has been merged with the unparser. The <code>unparse ( object -- string )</code> word has been moved to the <code>prettyprint</code> vocabulary, and can now produce a parsable string for any class supported by the prettyprinter.</li>
<li>New <code>unparse-short ( object -- string )</code> returns a string no longer than a single line.</li>
<li>The prettyprinter now supports many more configuration variables. See the handbook for details.</li>
<li>New <code>profile ( word -- )</code> word. Causes the word's accumulative runtime to be stored in a global variable named by the word. This is done with the annotation facility, the word's definition is modified; use <code>reload ( word -- )</code> to get the old definition back from the source file.</li>
</ul>

</li>

<li>User interface:

<ul>
<li>Binary search is now used for spacial indexing where possible. This improves performance when there are a lot of lines of output in the listener.</li>
<li>Scroll bars now behave in a more intuitive manner, closer to conventional GUIs.</li>
<li>Menus now appear when the mouse button is pressed, not released, and dragging through the menu with the button held down behaves as one would expect.</li>
<li>The data stack and call stack are now shown. In the single-stepper, these two display the state of the program being stepped. In the inspector, the call stack display is replaced with an inspector history.</li>
<li>Pack layouts with gaps are now supported.</li>
<li>Many bug fixes.</li>
</ul>

</li>

<li>Everything else:

<ul>
<li>New <code>sleep ( ms -- )</code> word pauses current thread for a number of milliseconds.</li>
<li>New <code>with-datastack ( stack word -- stack )</code> combinator.</li>
<li>New <code>cond ( conditions -- )</code> combinator. It behaves like a set of nested <code>ifte</code>s, and compiles if each branch has the same stack effect. See its documentation comment for details.</li>
<li>Formally documented method combination (<code>G:</code> syntax) in handbook.</li>
<li>Erlang/Termite-style concurrency library in <code>contrib/concurrency</code> (Chris Double).</li>
<li>Completely redid infix algebra in <code>contrib/algebra/</code>. Now, vector operations are possible
and the syntax doesn't use so many spaces. New way to write the quadratic formula:
<pre>MATH: quadratic[a;b;c] =
    plusmin[(-b)/2*a;(sqrt(b^2)-4*a*c)/2*a] ;</pre>
(Daniel Ehrenberg)</li>
<li>Support for client sockets on Windows. (Mackenzie Straight)</li>
</ul>

</li>

</ul>

<h1>Factor 0.76:</h1>

<ul>
<li>
UI framework:
<ul>
<li>Now uses 3-dimensional co-ordinates throughout</li>
<li>Gradient paint, bevel border paint</li>
<li>Split pane gadget</li>
<li>Horizontal scroll bars and wheel mouse scrolling in scroller gadgets</li>
<li>Incremental layout improves listener responsiveness</li>
<li>The listener supports styled text output and presentations</li>
<li>Slide-show tutorial with live code examples</li>
<li>Performance improvements, code cleanups, bug fixes</li>
</ul>
</li>
<li>
Sequences:
<ul>
<li>The following formely list-specific words are now generic:
    
    <pre>all? ( seq quot -- ? | quot: elt -- ? )
all-with? ( obj seq quot -- ? | quot: elt -- ? )
subset ( seq quot -- seq | quot: elt -- ? )
subset-with ( obj seq quot -- seq | quot: obj elt -- ? )
fiber? ( seq quot -- ? | quot: elt elt -- ? )
prune ( seq -- seq )</pre>

<li> The <code>contains?</code> word for testing membership in a sequence has been
  renamed to <code>member? ( elt seq -- ? )</code>.

<li> The list-specific <code>some?</code> and <code>some-with?</code> combinators are gone. Their replacements are generic:
  
  <pre>contains? ( seq quot -- ? | quot: elt -- ? )
contains-with? ( obj seq quot -- ? | quot: obj elt -- ? )
find ( seq quot -- i elt | quot: elt -- ? )
find* ( i seq quot -- i elt | quot: elt -- ? )
find-with ( obj seq quot -- i elt | quot: elt -- ? )
find-with* ( obj i seq quot -- i elt | quot: elt -- ? )</pre>

  See the developer's handbook for details.

<li> The <code>nreverse ( seq -- )</code> word has been removed.

<li> <code>reverse-slice ( seq -- seq )</code> outputs a new sequence that shares
  structure with the given sequence, but presents elements in reverse
  order.

<li> The <code>string-compare</code> primitive has been replaced with the lexi word
  which now operates on any pair of sequences of numbers. The
  string> word has been replaced with <code>lexi></code>.

<li> The <code>,</code> word no longer accepts a string as input inside a <code>make-string</code>. In 0.75, the following
  two lines were equivalent:
  
  <pre>[ "Hello" , " world" , ] make-string
[ "Hello" % " world" % ] make-string</pre>
  
<li> Now, the former raises a type error. Use <code>,</code> with characters, and <code>%</code> with
  strings inside make-string.
</ul>

<li>Streams:

<ul>
<li>The following words have been renamed:
  
    <pre>stream-auto-flush ==> stream-finish ( stream -- )
stream-write-attr ==> stream-format ( string style stream -- )
write-attr ==> format ( string style -- )</pre>

<li>The following words no longer accept character arguments:
  
    <pre>stream-format ( string style stream -- )
format ( string style -- )
stream-write ( string stream -- )
write ( string -- )
stream-print ( string -- )
print ( string -- )</pre>

<li>Use the new words to write characters:
  
    <pre>stream-write1 ( char stream -- )
write1 ( char -- )</pre>

  Note that <code>stream-write1</code> is generic and your stream must implement it.

<li><code>with-string</code> word renamed to <code>string-out ( quot -- string )</code>

<li>New <code>string-in ( string quot -- )</code> word, calls <code>quot</code> with <code>stdio</code> bound to
  a stream that reads from the given string.
</ul>

<li>Everything else:

<ul>

<li>Many improvements to the matrices library.

<li>Improved inspector. Call it with <code>inspect ( obj -- )</code>.

<li>The number of generations used for garbage collection can now be set
  with the +G command line switch. You must specify at least 2
  generations.

<li>Only 2 generations are used by default now, since there seems to be no
  performance benefit to having 3 after running some brief benchmarks.

<li>Fixed bug where images saved from the jEdit plugin would fail to
  start.

<li>md5 hashing algorithm in <code>contrib/crypto/</code> (Doug Coleman).


</ul>

</ul>

</body>
</html>
