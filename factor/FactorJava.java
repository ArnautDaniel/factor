/* :folding=explicit:collapseFolds=1: */

/*
 * $Id$
 *
 * Copyright (C) 2003, 2004 Slava Pestov.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * DEVELOPERS AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package factor;

import factor.compiler.FactorCompiler;
import java.lang.reflect.*;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import org.objectweb.asm.*;

/**
 * A few methods for converting between Java types, and making reflection calls.
 * Note that the compiler incorporates calls to some of these methods in
 * generated bytecode.
 */
public class FactorJava implements Constants
{
	public static final Class[] EMPTY_ARRAY = new Class[0];

	//{{{ classNameToClassList() method
	public static Class[] classNameToClassList(Cons classes)
		throws Exception
	{
		if(classes == null)
			return EMPTY_ARRAY;

		Class[] _classes = new Class[classes.length()];
		int i = 0;
		while(classes != null)
		{
			Object car = classes.car;
			if(car instanceof Cons)
			{
				Cons classSpec = (Cons)car;
				if(classSpec.cdr != null)
				{
					throw new FactorRuntimeException(
						"Bad class spec: " + car);
				}
				Class clazz = (Class)classSpec.car(Class.class);
				if(clazz.isPrimitive())
				{
					_classes[i] = getClass("["
						+ javaClassToVMClass(clazz));
				}
				else
				{
					_classes[i] = getClass("[L"
						+ clazz.getName() + ";");
				}
			}
			else
				_classes[i] = (Class)classes.car(Class.class);

			i++;
			classes = classes.next();
		}

		return _classes;
	} //}}}

	//{{{ toNumber() method
	public static Number toNumber(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return (Number)arg;
		else if(arg instanceof String)
		{
			String str = (String)arg;
			if(str.indexOf('.') != -1)
				return new Float(str);
			else
				return new Integer(str);
		}
		else
			throw new FactorDomainException(arg,Number.class);
	} //}}}

	//{{{ toString() method
	public static String toString(Object arg)
	{
		if(arg == null)
			return null;
		else if(arg instanceof String)
			return (String)arg;
		else
			return String.valueOf(arg);
	} //}}}

	//{{{ toBoolean() method
	public static boolean toBoolean(Object arg)
	{
		if(Boolean.FALSE.equals(arg) || arg == null)
			return false;
		else
			return true;
	} //}}}

	//{{{ toByte() method
	public static byte toByte(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return ((Number)arg).byteValue();
		else if(arg instanceof String)
			return Byte.parseByte((String)arg);
		else
			throw new FactorDomainException(arg,byte.class);
	} //}}}

	//{{{ toChar() method
	public static char toChar(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Character)
			return ((Character)arg).charValue();
		else if(arg == null)
			return '\0';
		else if(arg instanceof String)
		{
			String s = (String)arg;
			if(s.length() != 1)
				throw new FactorDomainException(arg,char.class);
			return s.charAt(0);
		}
		else if(arg instanceof Number)
		{
			return (char)((Number)arg).intValue();
		}
		else
			throw new FactorDomainException(arg,char.class);
	} //}}}

	//{{{ toInt() method
	public static int toInt(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return ((Number)arg).intValue();
		else if(arg instanceof String)
			return Integer.parseInt((String)arg);
		else
			throw new FactorDomainException(arg,int.class);
	} //}}}

	//{{{ toLong() method
	public static long toLong(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return ((Number)arg).longValue();
		else if(arg instanceof String)
			return Long.parseLong((String)arg);
		else
			throw new FactorDomainException(arg,long.class);
	} //}}}

	//{{{ toFloat() method
	public static float toFloat(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return ((Number)arg).floatValue();
		else if(arg instanceof String)
			return Float.parseFloat((String)arg);
		else
			throw new FactorDomainException(arg,float.class);
	} //}}}

	//{{{ toDouble() method
	public static double toDouble(Object arg)
		throws FactorDomainException
	{
		if(arg instanceof Number)
			return ((Number)arg).doubleValue();
		else if(arg instanceof String)
			return Double.parseDouble((String)arg);
		else
			throw new FactorDomainException(arg,double.class);
	} //}}}

	//{{{ toClass() method
	public static Class toClass(Object arg)
		throws Exception
	{
		if(arg instanceof Class)
			return (Class)arg;
		else
		{
			return getClass((String)
				convertToJavaType(arg,String.class));
		}
	} //}}}

	//{{{ toNamespace() method
	public static FactorNamespace toNamespace(Object obj,
		FactorInterpreter interp) throws Exception
	{
		if(obj instanceof FactorNamespace)
			return (FactorNamespace)obj;
		else if(obj instanceof FactorObject)
		{
			FactorNamespace ns = ((FactorObject)obj)
				.getNamespace(interp);
			if(ns == null)
				throw new FactorRuntimeException(
					obj + " has a null"
					+ " namespace");
			return ns;
		}
		else
		{
			throw new FactorDomainException(obj,
				FactorObject.class);
		}
	} //}}}

	//{{{ toBooleanArray() method
	public static boolean[] toBooleanArray(Object arg)
		throws FactorDomainException
	{
		if(arg == null)
			return new boolean[0];
		else if(arg instanceof Cons)
			arg = toArray(arg,Object[].class);

		try
		{
			boolean[] returnValue = new boolean[
				Array.getLength(arg)];
			for(int i = 0; i < returnValue.length; i++)
			{
				returnValue[i] = toBoolean(
					Array.get(arg,i));
			}
			return returnValue;
		}
		catch(IllegalArgumentException e)
		{
			throw new FactorDomainException(arg,boolean[].class);
		}
	} //}}}

	//{{{ toByteArray() method
	public static byte[] toByteArray(Object arg)
		throws FactorDomainException
	{
		if(arg == null)
			return new byte[0];
		else if(arg instanceof Cons)
			arg = toArray(arg,Object[].class);

		try
		{
			byte[] returnValue = new byte[
				Array.getLength(arg)];
			for(int i = 0; i < returnValue.length; i++)
			{
				returnValue[i] = toByte(
					Array.get(arg,i));
			}
			return returnValue;
		}
		catch(IllegalArgumentException e)
		{
			throw new FactorDomainException(arg,byte[].class);
		}
	} //}}}

	//{{{ toArray() method
	public static Object[] toArray(Object arg)
		throws FactorDomainException
	{
		return toArray(arg,Object[].class);
	} //}}}

	//{{{ toArray() method
	public static Object[] toArray(Object arg, Class clas)
		throws FactorDomainException
	{
		if(arg == null)
		{
			return (Object[])Array.newInstance(
				clas.getComponentType(),0);
		}
		else if(arg instanceof Cons)
		{
			Cons list = (Cons)arg;
			Object[] array = (Object[])
				Array.newInstance(
				clas.getComponentType(),
				list.length());
			list.toArray(array);
			return array;
		}
		else if(arg.getClass().isArray())
		{
			if(arg.getClass() == clas)
				return (Object[])arg;
			else
			{
				Object[] _arg = (Object[])arg;
				Object[] array = (Object[])
					Array.newInstance(
					clas.getComponentType(),
					_arg.length);
				System.arraycopy(arg,0,array,0,
					_arg.length);
				return array;
			}
		}
		else
			throw new FactorDomainException(arg,Object[].class);
	} //}}}

	//{{{ convertToJavaType() method
	public static Object convertToJavaType(Object arg, Class clas)
		throws Exception
	{
		if(clas == Object.class)
			return arg;
		else if(clas == Number.class)
		{
			return toNumber(arg);
		}
		else if(clas == String.class)
		{
			return toString(arg);
		}
		else if(clas == boolean.class)
		{
			return toBoolean(arg)
				? Boolean.TRUE
				: Boolean.FALSE;
		}
		else if(clas == byte.class)
		{
			return new Byte(toByte(arg));
		}
		else if(clas == char.class)
		{
			return new Character(toChar(arg));
		}
		else if(clas == int.class)
		{
			return new Integer(toInt(arg));
		}
		else if(clas == long.class)
		{
			return new Long(toLong(arg));
		}
		else if(clas == float.class)
		{
			return new Float(toFloat(arg));
		}
		else if(clas == double.class)
		{
			return new Double(toDouble(arg));
		}
		else if(clas == Class.class)
		{
			return toClass(arg);
		}
		else if(clas.isArray())
		{
			Class comp = clas.getComponentType();
			if(!comp.isPrimitive())
				return toArray(arg,clas);
			else if(comp == boolean.class)
				return toBooleanArray(arg);
		}

		if(arg != null && !clas.isInstance(arg))
			throw new FactorDomainException(arg,clas);
		else
			return arg;
	} //}}}

	//{{{ fromBoolean() method
	public static Object fromBoolean(boolean b)
	{
		return (b ? Boolean.TRUE : null);
	} //}}}

	//{{{ convertFromJavaType() method
	public static Object convertFromJavaType(Object arg)
	{
		if(Boolean.FALSE.equals(arg))
			return null;
		else
			return arg;
	} //}}}

	//{{{ javaClassToVMClass() method
	public static String javaClassToVMClass(Class clazz)
	{
		String name = clazz.getName();

		if(clazz.isArray())
			return clazz.getName().replace('.','/');
		else if(name.equals("boolean"))
			return "Z";
		else if(name.equals("byte"))
			return "B";
		else if(name.equals("char"))
			return "C";
		else if(name.equals("double"))
			return "D";
		else if(name.equals("float"))
			return "F";
		else if(name.equals("int"))
			return "I";
		else if(name.equals("long"))
			return "J";
		else if(name.equals("short"))
			return "S";
		else if(name.equals("void"))
			return "V";
		else
			return "L" + clazz.getName().replace('.','/') + ";";
	} //}}}

	//{{{ javaBoxingType() method
	public static Class javaBoxingType(Class clazz)
	{
		if(clazz == Byte.TYPE)
			return Byte.class;
		else if(clazz == Character.TYPE)
			return Character.class;
		else if(clazz == Double.TYPE)
			return Double.class;
		else if(clazz == Float.TYPE)
			return Float.class;
		else if(clazz == Integer.TYPE)
			return Integer.class;
		else if(clazz == Long.TYPE)
			return Long.class;
		else if(clazz == Short.TYPE)
			return Short.class;
		else
			return null;
	} //}}}

	//{{{ javaSignatureToVMSignature() method
	public static String javaSignatureToVMSignature(Class[] args,
		Class returnType)
	{
		StringBuffer buf = new StringBuffer("(");
		for(int i = 0; i < args.length; i++)
		{
			buf.append(javaClassToVMClass(args[i]));
		}
		buf.append(")");
		buf.append(javaClassToVMClass(returnType));
		return buf.toString();
	} //}}}

	//{{{ getClass() method
	public static Class getClass(String name) throws ClassNotFoundException
	{
		if(name.equals("boolean"))
			return Boolean.TYPE;
		else if(name.equals("byte"))
			return Byte.TYPE;
		else if(name.equals("char"))
			return Character.TYPE;
		else if(name.equals("double"))
			return Double.TYPE;
		else if(name.equals("float"))
			return Float.TYPE;
		else if(name.equals("int"))
			return Integer.TYPE;
		else if(name.equals("long"))
			return Long.TYPE;
		else if(name.equals("short"))
			return Short.TYPE;
		else
			return Class.forName(name);
	} //}}}

	//{{{ jconstructor() method
	public static Constructor jconstructor(String inClass, Cons args)
		throws Exception
	{
		return Class.forName(inClass).getConstructor(
			classNameToClassList(args));
	} //}}}

	//{{{ jfield() method
	public static Field jfield(String field, String inClass)
		throws Exception
	{
		return Class.forName(inClass).getField(field);
	} //}}}

	//{{{ jinvoke() method
	public static void jinvoke(FactorDataStack stack, Method method,
		Object instance) throws Exception
	{
		if(instance != null)
		{
			instance = convertToJavaType(instance,
				method.getDeclaringClass());
		}

		Class[] paramTypes = method.getParameterTypes();
		Object[] args = new Object[paramTypes.length];

		try
		{
			for(int i = args.length - 1; i >= 0; i--)
			{
				args[i] = convertToJavaType(stack.pop(),
					paramTypes[i]);
			}

			if(Modifier.isStatic(method.getModifiers()))
			{
				if(instance != null)
					throw new FactorRuntimeException(
						"Use jinvokeStatic with static methods");
			}
			else
			{
				if(instance == null)
					throw new FactorRuntimeException(
						"Cannot jinvoke on f");
			}

			if(method.getReturnType() == Void.TYPE)
				method.invoke(instance,args);
			else
			{
				stack.push(convertFromJavaType(
					method.invoke(instance,args)));
			}
		}
		catch(FactorStackException e)
		{
			throw new FactorStackException(paramTypes.length);
		}
	} //}}}

	//{{{ jinvokeStatic() method
	public static void jinvokeStatic(FactorDataStack stack, Method method)
		throws Exception
	{
		jinvoke(stack,method,null);
	} //}}}

	//{{{ jmethod() method
	public static Method jmethod(String method, String inClass,
		Cons args) throws Exception
	{
		return Class.forName(inClass).getMethod(method,
			classNameToClassList(args));
	} //}}}

	//{{{ jnew() method
	public static void jnew(FactorDataStack stack, Constructor method)
		throws Exception
	{
		Class[] paramTypes = method.getParameterTypes();
		Object[] args = new Object[paramTypes.length];
		for(int i = args.length - 1; i >= 0; i--)
		{
			args[i] = convertToJavaType(stack.pop(),
				paramTypes[i]);
		}
	        
		stack.push(method.newInstance(args));
	} //}}}

	//{{{ jvarGet() method
	public static Object jvarGet(Field field, Object obj) throws Exception
	{
		return convertFromJavaType(field.get(obj));
	} //}}}

	//{{{ jvarGetStatic() method
	public static Object jvarGetStatic(Field field) throws Exception
	{
		return convertFromJavaType(field.get(null));
	} //}}}

	//{{{ jvarSet() method
	public static void jvarSet(Field field, Object obj, Object value)
		throws Exception
	{
		field.set(obj,convertToJavaType(value,field.getType()));
	} //}}}

	//{{{ jvarSetStatic() method
	public static void jvarSetStatic(Field field, Object value)
		throws Exception
	{
		field.set(null,convertToJavaType(value,field.getType()));
	} //}}}

	//{{{ unwrapException() method
	public static Throwable unwrapException(Throwable e)
	{
		if(e instanceof InvocationTargetException)
		{
			return unwrapException(
				((InvocationTargetException)e)
				.getTargetException());
		}
		else if(e.getCause() != null)
			return unwrapException(e.getCause());
		else
			return e;
	} //}}}

	//{{{ getConversionMethodName() method
	/**
	 * Returns method name for converting an object to the given type.
	 * Only for primitives.
	 */
	public static String getConversionMethodName(Class type)
	{
		if(type == short.class)
		{
			// not yet done.
			return null;
		}
		else if(type.isPrimitive())
		{
			String name = type.getName();
			return "to"
				+ Character.toUpperCase(name.charAt(0))
				+ name.substring(1);
		}
		else
			return null;
	} //}}}

	//{{{ generateFromConversion() method
	/**
	 * Unbox value at top of the stack.
	 */
	public static void generateFromConversion(CodeVisitor mw, Class type)
		throws Exception
	{
		if(type == Object.class)
			return;

		String methodName = null;
		boolean interpArg = false;

		if(type == Number.class)
			methodName = "toNumber";
		else if(type == String.class)
			methodName = "toString";
		else if(type == short.class
			|| type == byte.class
			|| type == char.class)
		{
			// not yet done.
			methodName = null;
		}
		else if(type.isPrimitive())
			methodName = getConversionMethodName(type);
		else if(type == Class.class)
			methodName = "toClass";
		else if(type == FactorNamespace.class)
		{
			methodName = "toNamespace";
			interpArg = true;
		}
		else if(type.isArray())
		{
			Class comp = type.getComponentType();
			if(comp.isPrimitive())
			{
				methodName = getConversionMethodName(comp)
					+ "Array";
			}
			else
				methodName = "toArray";
		}

		if(methodName == null)
		{
			mw.visitTypeInsn(CHECKCAST,
				type.getName()
				.replace('.','/'));
		}
		else
		{
			if(interpArg)
			{
				mw.visitVarInsn(ALOAD,0);
				mw.visitMethodInsn(INVOKESTATIC,
					"factor/FactorJava",
					methodName,
					"(Ljava/lang/Object;Lfactor/FactorInterpreter;)"
					+ FactorJava.javaClassToVMClass(type));
			}
			else
			{
				mw.visitMethodInsn(INVOKESTATIC,
					"factor/FactorJava",
					methodName,
					"(Ljava/lang/Object;)"
					+ FactorJava.javaClassToVMClass(type));
			}
		}
	} //}}}

	//{{{ generateToConversionPre() method
	/**
	 * Avoid having to deal with category 1/2 computational type
	 * distinction.
	 */
	public static boolean generateToConversionPre(CodeVisitor mw,
		Class type) throws Exception
	{
		if(type != boolean.class)
		{
			Class boxingType = FactorJava.javaBoxingType(type);
			if(boxingType != null)
			{
				String boxingName = boxingType.getName()
					.replace('.','/');
				mw.visitTypeInsn(NEW,boxingName);
				mw.visitInsn(DUP);

				return true;
			}
		}

		return false;
	} //}}}

	//{{{ generateToConversion() method
	/**
	 * Box return value, if needed.
	 */
	public static void generateToConversion(CodeVisitor mw, Class type)
		throws Exception
	{
		if(type == boolean.class)
		{
			// this case is handled specially
			mw.visitMethodInsn(INVOKESTATIC,
				"factor/FactorJava",
				"fromBoolean",
				"(Z)Ljava/lang/Object;");
		}
		else
		{
			Class boxingType = FactorJava.javaBoxingType(type);
			if(boxingType != null)
			{
				String boxingName = boxingType.getName()
					.replace('.','/');
				mw.visitMethodInsn(INVOKESPECIAL,boxingName,
					"<init>",
					"(" + FactorJava.javaClassToVMClass(
					type) + ")V");
			}
		}
	} //}}}
}
